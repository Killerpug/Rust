<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>AsciidocFX Editor</title>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="index%20Archivos/a_004.css" type="text/css">
    <link rel="stylesheet" href="index%20Archivos/a_002.css" type="text/css">
    <link rel="stylesheet" href="index%20Archivos/a.css" type="text/css">
    <link rel="stylesheet" href="index%20Archivos/a_006.css">
    <link rel="stylesheet" href="index%20Archivos/a_005.css">
    <link rel="stylesheet" href="index%20Archivos/a_003.css">
</head>
<body>
<div class="asciidocfx-container">
    <div id="placeholder"><h1>Rust Programming Language</h1>
<div id="toc" class="toc">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#trueoverview">1. Overview</a>
<ul class="sectlevel2">
<li><a href="#truecharacteristics">1.1. Characteristics</a></li>
<li><a href="#truedeveloper_tools_in_rust">1.2. Developer tools in Rust</a></li>
<li><a href="#truefields_on_rust">1.3. Fields on Rust</a></li>
<li><a href="#truecompiling">1.4. Compiling</a></li>
</ul>
</li>
<li><a href="#truerust_fundamentals">2. Rust Fundamentals</a>
<ul class="sectlevel2">
<li><a href="#truevariables">2.1. Variables</a></li>
<li><a href="#truedata_types">2.2. Data Types</a></li>
<li><a href="#truestrings">2.3. Strings</a></li>
<li><a href="#trueoperators">2.4. Operators</a></li>
<li><a href="#truefunctions_methods">2.5. Functions &amp; Methods</a></li>
<li><a href="#truefailures">2.6. Failures</a></li>
<li><a href="#truescope">2.7. Scope {}</a></li>
<li><a href="#trueloops">2.8. Loops</a></li>
</ul>
</li>
<li><a href="#truestack_heap">3. Stack &amp; Heap</a></li>
<li><a href="#trueownership">4. Ownership</a>
<ul class="sectlevel2">
<li><a href="#trueownership_rules">4.1. Ownership Rules</a></li>
<li><a href="#trueinteracting_with_data_move_if_heap_copy_if_stack">4.2. Interacting with data: Move if Heap, Copy if Stack.</a></li>
</ul>
</li>
<li><a href="#truereference_and_borrowing">5. Reference (&amp;) and borrowing</a>
<ul class="sectlevel2">
<li><a href="#truethe_rules_of_references">5.1. The Rules of References</a></li>
<li><a href="#trueborrowing">5.2. Borrowing</a></li>
<li><a href="#truemutable_references">5.3. Mutable references</a></li>
<li><a href="#truedangling_references">5.4. Dangling references</a></li>
</ul>
</li>
<li><a href="#truestructures">6. Structures</a>
<ul class="sectlevel2">
<li><a href="#truetuple_structure">6.1. Tuple structure</a></li>
<li><a href="#truemethods_2">6.2. Methods</a></li>
<li><a href="#trueassociated_functions">6.3. Associated functions</a></li>
<li><a href="#truederived_traits">6.4. Derived traits</a></li>
<li><a href="#truewheres_the_operator">6.5. Where’s the → Operator?</a></li>
</ul>
</li>
<li><a href="#trueenums_and_pattern_matching">7. Enums and pattern matching</a>
<ul class="sectlevel2">
<li><a href="#trueoption_enum_vs_null">7.1. Option enum vs Null</a></li>
<li><a href="#truematch">7.2. match</a></li>
<li><a href="#trueif_let_concise_control_flow">7.3. if-let, concise control flow</a></li>
</ul>
</li>
<li><a href="#truemanaging_growing_projects_with_packages_crates_and_modules">8. Managing growing projects with packages, crates and modules</a>
<ul class="sectlevel2">
<li><a href="#truepackages_and_crates">8.1. Packages and crates</a></li>
<li><a href="#truedefining_modules_to_control_scope_and_privacy">8.2. Defining modules to control scope and privacy</a></li>
<li><a href="#trueexternal_packages">8.3. External packages</a></li>
<li><a href="#trueseparating_modules_into_different_files">8.4. Separating modules into different files.</a></li>
</ul>
</li>
<li><a href="#truecommon_collections">9. Common collections</a>
<ul class="sectlevel2">
<li><a href="#truevectors">9.1. Vectors</a></li>
<li><a href="#truehash_maps">9.2. Hash Maps</a></li>
</ul>
</li>
<li><a href="#trueerror_handling">10. Error Handling</a>
<ul class="sectlevel2">
<li><a href="#trueunrecoverable_errors_with_panic">10.1. Unrecoverable errors with panic!</a></li>
<li><a href="#truerecoverable_errors_with_result">10.2. Recoverable errors with Result</a></li>
<li><a href="#trueto_panic_or_not_to_panic">10.3. to panic! or not to panic!</a></li>
</ul>
</li>
<li><a href="#truegeneric_types_traits_and_lifetimes">11. Generic Types, Traits and Lifetimes</a>
<ul class="sectlevel2">
<li><a href="#truegeneric_data_types">11.1. Generic Data Types</a></li>
<li><a href="#truetraits_defining_shared_behavior">11.2. Traits: Defining shared behavior</a></li>
<li><a href="#truetraits_as_parameters">11.3. Traits as parameters</a></li>
<li><a href="#truevalidating_references_with_lifetimes">11.4. Validating references with Lifetimes</a></li>
<li><a href="#truepredictable_lifetime_by_elision_rules">11.5. Predictable Lifetime by elision rules</a></li>
</ul>
</li>
<li><a href="#truewriting_automated_test">12. Writing automated test</a>
<ul class="sectlevel2">
<li><a href="#truehow_to_write_tests">12.1. How to write tests</a></li>
<li><a href="#truecontrolling_how_test_are_run">12.2. Controlling how test are run</a></li>
<li><a href="#truetest_organization">12.3. Test organization</a></li>
</ul>
</li>
<li><a href="#truefunctional_features_closures_and_iterators">13. Functional features: Closures and Iterators</a>
<ul class="sectlevel2">
<li><a href="#trueclosures">13.1. Closures</a></li>
<li><a href="#trueclosure_features">13.2. Closure features</a></li>
<li><a href="#truecache_storing_closures_using_generic_parameters_and_traits">13.3. Cache: Storing closures using generic parameters and traits</a></li>
<li><a href="#truecapturing_environment_with_closures">13.4. Capturing environment with closures</a></li>
<li><a href="#trueiterators">13.5. Iterators</a></li>
</ul>
</li>
<li><a href="#truemore_about_cargo_and_crates_io">14. More about Cargo and Crates.io</a>
<ul class="sectlevel2">
<li><a href="#truecustomizing_builds_with_release_profiles">14.1. Customizing builds with release profiles</a></li>
<li><a href="#truedocumenting_and_publishing_a_crate_to_crates_io">14.2. Documenting and publishing a Crate to Crates.io</a></li>
<li><a href="#truecargo_workspaces">14.3. Cargo workspaces</a></li>
</ul>
</li>
<li><a href="#truesmart_pointers">15. Smart Pointers</a>
<ul class="sectlevel2">
<li><a href="#trueusing_boxt_to_point_to_data_on_the_heap">15.1. Using Box&lt;T&gt; to Point to Data on the Heap</a></li>
<li><a href="#trueimplementing_dereference_trait">15.2. Implementing Dereference trait</a></li>
<li><a href="#truedrop_trait">15.3. Drop Trait</a></li>
<li><a href="#truerct_the_reference_counted_smart_pointer">15.4. RC&lt;T&gt; the reference counted smart pointer</a></li>
<li><a href="#truerefcellt_interior_mutability_pattern">15.5. RefCell&lt;T&gt; interior mutability pattern</a></li>
<li><a href="#truememory_leaks">15.6. Memory leaks</a></li>
</ul>
</li>
<li><a href="#truefearless_concurrencyand_or_parallel">16. Fearless Concurrency(and or parallel)</a>
<ul class="sectlevel2">
<li><a href="#trueusing_threads_to_run_code_simultaneously">16.1. Using threads to run code simultaneously</a></li>
<li><a href="#trueusing_message_passing_to_transfer_data_between_threads">16.2. Using message passing to transfer data between threads</a></li>
<li><a href="#trueshared_state_concurrency">16.3. Shared-state Concurrency</a></li>
<li><a href="#trueembedded_concurrency_with_sync_and_send_traits">16.4. Embedded concurrency with Sync and Send traits</a></li>
</ul>
</li>
<li><a href="#trueobject_oriented_programming">17. Object Oriented Programming</a>
<ul class="sectlevel2">
<li><a href="#trueusing_trait_objects_allow_values_of_different_types">17.1. Using trait objects: Allow values of different types</a></li>
<li><a href="#trueimplementing_object_oriented_design_pattern">17.2. Implementing Object-Oriented design pattern</a></li>
</ul>
</li>
<li><a href="#truepatterns_and_matching">18. Patterns and Matching</a>
<ul class="sectlevel2">
<li><a href="#truepatterns_use_cases">18.1. Patterns use cases</a></li>
<li><a href="#truerefutability_wether_a_pattern_might_fail_or_match">18.2. Refutability: wether a pattern might Fail or match</a></li>
</ul>
</li>
<li><a href="#trueadvanced_features">19. Advanced features</a>
<ul class="sectlevel2">
<li><a href="#trueunsafe_rust">19.1. Unsafe Rust</a></li>
</ul>
</li>
</ul>
</div>
<div class="sect1 data-line-13">
<h2 id="trueoverview">1. Overview</h2>
<div class="sectionbody">
<div class="sect2 data-line-14">
<h3 id="truecharacteristics">1.1. Characteristics</h3>
<div class="ulist data-line-15">
<ul>
<li class="data-line-15">
<p>Precompiled just like C.</p>
</li>
<li class="data-line-16">
<p>zero-cost abstractions: higher-level features that compile to lower-level code as fast as code written manually.</p>
</li>
<li class="data-line-17">
<p>Includes the official building system &amp; packet manager <strong>Cargo</strong>, allowing the user to control and build dependencies.</p>
</li>
<li class="data-line-18">
<p><strong>Snake case</strong> as the conventional style for function 
and variable names. In snake case, all letters are lowercase and 
underscores separate words. E.g. variable_name;</p>
</li>
</ul>
</div>
</div>
<div class="sect2 data-line-20">
<h3 id="truedeveloper_tools_in_rust">1.2. Developer tools in Rust</h3>
<div class="ulist data-line-21">
<ul>
<li class="data-line-21">
<p><strong>Cargo</strong>: the included dependency manager and build 
tool(similar to Makefile but native), makes adding, compiling, and 
managing dependencies painless and consistent across the Rust ecosystem.
Cargo has a mechanism that ensures you can rebuild the same artifact 
every build (Cargo.TOML). Cargo will use only the versions of the 
dependencies you specified until you indicate otherwise. To ignore 
manual versions or to upgrade a package use <span class="underline">cargo update</span> (-update_only_optional_Packet) which will update dependencies to latest versions.</p>
</li>
<li class="data-line-23">
<p><strong>Rustfmt</strong>: ensures a consistent coding style across developers.</p>
</li>
<li class="data-line-24">
<p>The Rust <strong>Language Server</strong>: powers Integrated Development Environment (IDE) integration for code completion and inline error messages.</p>
</li>
<li class="data-line-25">
<p><strong>Crate</strong>: collection of Rust source code files (Basically a library).</p>
</li>
<li class="data-line-26">
<p>The <strong>Prelude</strong> is the most basic library that possesses
 the minimum functionalities that Rust need to import into every 
program, it includes traits of fundamental types, destructors and 
overloading, heap allocation, ownership, clone, comparison traits, 
generic conversions, iterators, heap allocated strings and vectors.</p>
</li>
</ul>
</div>
</div>
<div class="sect2 data-line-28">
<h3 id="truefields_on_rust">1.3. Fields on Rust</h3>
<div class="paragraph data-line-29">
<p>Command line tools, web services, DevOps tooling, embedded devices, 
audio and video analysis and transcoding, cryptocurrencies, 
bioinformatics, search engines, Internet of Things applications, machine
 learning, and even major parts of the Firefox web browser.</p>
</div>
</div>
<div class="sect2 data-line-31">
<h3 id="truecompiling">1.4. Compiling</h3>
<table class="tableblock frame-all grid-all stretch data-line-35">
<caption class="title">Table 1. Compiling your project</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Instruction</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo new {name} <br>
    --lib</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generates the packet manager folder for Cargo to manage your rust project<br>
    — Creates a library(lib.rs)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo build<br>
--release<br>
--target {TRIPLET}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Compiles Rust program and creates an executable file in target/debug folder<br>
 — Compiles with optimizations (superfast code however is slower compilation time)<br>
 — Cross-compiles for a target denoted by the TRIPLET. E.g. thumbv7m-none-eabi</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">./target/debug/{Cargo_File}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Runs the program stored on the Default path of the project, once Cargo builds the project.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo run</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Builds and runs the program in one step.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo check</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Check correct compiling without producing an executable (speed-up the process)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Import library</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cargo readobj --bin {project}<br>
 — -file-headers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">can print the ELF headers to confirm that this is an ARM binary</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo-size --bin {project} --release — -A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">can print the size of the linker sections of the binary.</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cargo fmt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reformats your code according community code style</p></td>
</tr>
</tfoot>
</table>
</div>
</div>
</div>
<div class="sect1 data-line-60">
<h2 id="truerust_fundamentals">2. Rust Fundamentals</h2>
<div class="sectionbody">
<div class="sect2 data-line-61">
<h3 id="truevariables">2.1. Variables</h3>
<div class="paragraph data-line-62">
<p>let → Creates a variable.</p>
</div>
<div class="paragraph data-line-64">
<p>{}  → Curly brackets are the “format specifiers” (similar to % in C) of Rust. In Rust they are just a place holder.
E.g. Print to console</p>
</div>
<div class="listingblock data-line-67">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs">a) <span class="hljs-built_in">println!</span> (<span class="hljs-string">"x = {} and y = {}"</span>, x, y); 		<span class="hljs-comment">// Prints the output to the screen.</span>
b) <span class="hljs-keyword">let</span> s = <span class="hljs-built_in">format!</span> (<span class="hljs-string">"x = {} and y = {}"</span>, x, y);  	<span class="hljs-comment">// Returns a String with the contents (but doesn’t print anything)</span></code></pre>
</div>
</div>
<div class="paragraph data-line-72">
<p>There exist a lot of format specifiers for rust, for example:</p>
</div>
<div class="listingblock data-line-74">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-built_in">println!</span>(<span class="hljs-string">"{} (U+{:04X}) "</span>, c, c <span class="hljs-keyword">as</span> <span class="hljs-built_in">u32</span>);
$ cargo run --quiet -- <span class="hljs-string">"aimée"</span> 	<span class="hljs-comment">// a (U+0061) i (U+0069) m (U+006D) é (U+00E9) e (U+0065)</span></code></pre>
</div>
</div>
<div class="paragraph data-line-78">
<p>{:02X} – for individual bytes (change 2→4 for hexadecimals)</p>
</div>
</div>
<div class="sect2 data-line-80">
<h3 id="truedata_types">2.2. Data Types</h3>
<div class="paragraph data-line-81">
<p>Rust is a statically typed language, which means that it must know 
the types of all variables at compile time.  The compiler can usually 
infer what type we want to use based on the value and how we use it. In 
cases when many types are possible, such as when converting a String to a
 numeric type using parse, we must add a type annotation.</p>
</div>
<div class="sect3 data-line-83">
<h4 id="trueboolean_type">2.2.1. Boolean type</h4>
<div class="paragraph data-line-84">
<p>In Rust, Booleans are <span class="red">one byte</span> in size. Boolean type is specified by bool keyword: <code>let f: bool = false;</code></p>
</div>
<div class="listingblock data-line-86">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs">E.g. <span class="hljs-keyword">let</span> number = <span class="hljs-number">3</span>;
<span class="hljs-keyword">if</span> number { <span class="hljs-built_in">println!</span>(<span class="hljs-string">"number was three"</span>); }	<span class="hljs-comment">//Error: expected bool, found integer</span></code></pre>
</div>
</div>
<div class="paragraph data-line-90">
<p>Rust will <span class="red">not automatically</span> try to convert 
non-Boolean types to a Boolean, it must be explicit and provide a 
Boolean value for safety. Note that "if" does not require parenthesis.</p>
</div>
</div>
<div class="sect3 data-line-92">
<h4 id="truerusts_char_type">2.2.2. Rust’s char type</h4>
<div class="paragraph data-line-93">
<p>Char is <span class="red">always 4 bytes</span> in size that uses <span class="blue">codepoint←→UTF-8</span>
 (encoding method that uses 1-4 one-byte code units(Basically UTF-8 up 
to 4 bytes)) to represent Unicode characters(Unicode is a standard, 
which defines a map from characters to numbers, the so-called code 
points). Which means it can represent a lot more than just ASCII, like 
emojis with his 1,112,064 valid characters. However, <span class="underline">in a char not always the 4 bytes have information</span>. In UTF-8 encoding, the higher part indicates the #ofBytes needed to store the symbol ranging from 1 to 4 bytes:</p>
</div>
<div class="ulist data-line-95">
<ul>
<li class="data-line-95">
<p>If a byte starts with 0 it means <span class="blue">only one byte</span>(128
 different combinations) has information. For retrocompatibility, this 
characters represent the same 128 first characters as ASCII.</p>
</li>
<li class="data-line-96">
<p>If a byte starts with 110 it means we’ll use two bytes</p>
</li>
<li class="data-line-97">
<p>If a byte starts with 1110 it means we’ll use three bytes</p>
</li>
<li class="data-line-98">
<p>If a byte starts with 11110 it means we’ll use four bytes</p>
</li>
<li class="data-line-99">
<p>If a byte starts with 10, it means it’s a continuation of a multi-byte character sequence.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch data-line-104">
<caption class="title">Table 2. Code point &lt;→ UTF-8 conversion</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">First code point</th>
<th class="tableblock halign-left valign-top">Last code point</th>
<th class="tableblock halign-left valign-top">Byte 1</th>
<th class="tableblock halign-left valign-top">Byte 2</th>
<th class="tableblock halign-left valign-top">Byte 3</th>
<th class="tableblock halign-left valign-top">Byte 4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+0000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+007F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xxxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+0080</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+07FF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">110xxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+0800</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+FFFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1110xxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+10FFFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11110xxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-111">
<p>The following example encodes “é” by using 2 bytes(right align), leftover bits are filled with 0 (called padding).</p>
</div>
<div class="imageblock data-line-114">
<div class="content">
<img src="index%20Archivos/1_Encoding.png" alt="1 Encoding">
</div>
<div class="title">Figure 1. Encoding “é” in UTF-8 (? Represents a free bit for data)</div>
</div>
</div>
<div class="sect3 data-line-117">
<h4 id="trueinteger_type">2.2.3. Integer type</h4>
<div class="paragraph data-line-118">
<p>An integer is a number without a fractional component. It can be type annotated as follows:</p>
</div>
<div class="listingblock data-line-119">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> number = <span class="hljs-number">13</span>;		<span class="hljs-comment">//implicit data type</span>
<span class="hljs-keyword">let</span> number: <span class="hljs-built_in">i32</span> = <span class="hljs-number">13</span>;	<span class="hljs-comment">//explicit data type</span></code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all data-line-127" style="width: 50%;">
<caption class="title">Table 3. Integer types</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Length</th>
<th class="tableblock halign-left valign-top">Signed</th>
<th class="tableblock halign-left valign-top">Unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8-bit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">i8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">u8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">16-bit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">i16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">u16</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">32-bit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">i32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">u32</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">64-bit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">i64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">u64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">128-bit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">i128</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">u128</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arch (Architecture dependent)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">isize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">usize</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Rust defaults integers to i32</p></td>
</tr>
</tfoot>
</table>
<table class="tableblock frame-all grid-all data-line-141" style="width: 50%;">
<caption class="title">Table 4. Number literals</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Number literals</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Decimal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">98_222</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xff</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Octal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0o77</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Binary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0b1111_0000</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Byte (u8 only)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">b’A'</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-149">
<p>Signed numbers are stored using two’s complement representation. Furthermore, you can use “_” as a visual separator</p>
</div>
<div class="admonitionblock note data-line-152">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph data-line-153">
<p>Final note: Integer overflow</p>
</div>
<div class="ulist data-line-155">
<ul>
<li class="data-line-155">
<p>In debug mode, Rust includes checks for integer overflow that cause your program to panic at runtime if an overflow occurs.</p>
</li>
<li class="data-line-156">
<p>In release mode, rust doesn’t include checks. So, if overflow occurs,
 Rust performs two’s complement wrapping(256 becomes 0 in a u8). Relying
 on integer overflow is an error, you should explicitly handle these 
types of situation with wrapping_* methods(this is a reason why c 
produces unknown behaviors).</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3 data-line-159">
<h4 id="truefloat_type">2.2.4. Float type</h4>
<div class="paragraph data-line-160">
<p>f32(single precision) and f64(<strong>default</strong>, double 
precision) are used for numbers with decimal points. Floating-point 
numbers are represented according IEEE-754 standard.</p>
</div>
</div>
<div class="sect3 data-line-162">
<h4 id="truearrays_vs_vectors">2.2.5. Arrays vs Vectors</h4>
<div class="paragraph data-line-163">
<p><strong>Arrays</strong></p>
</div>
<div class="paragraph data-line-165">
<p>Arrays are useful when you want your data allocated on the <span class="green"><strong>stack</strong></span> rather than the heap or when you want to ensure you always have a <span class="underline">fixed</span> number of elements. E.g.</p>
</div>
<div class="listingblock data-line-167">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> a: [<span class="hljs-built_in">i32</span>; <span class="hljs-number">5</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];		 <span class="hljs-comment">//array with type i32 with 5 elements.</span>
<span class="hljs-keyword">let</span> a = [<span class="hljs-number">3</span>;<span class="hljs-number">5</span>]			<span class="hljs-comment">//array with 5 elements initialize with same value 3(due to “;”).</span></code></pre>
</div>
</div>
<div class="paragraph data-line-172">
<p>An array isn’t as flexible as the vector type though. A <strong>vector</strong> is a similar collection type provided by the standard library, it can grow or shrink in size(stored on <span class="green"><strong>heap</strong></span>).</p>
</div>
<div class="paragraph data-line-174">
<p><strong>Tuple</strong></p>
</div>
<div class="paragraph data-line-176">
<p>A tuple is a general way of <span class="underline">grouping together</span> several values with a variety of types into one compound type. Tuples have a fixed length: once declared, <span class="red">they cannot grow or shrink in size</span>.</p>
</div>
<div class="paragraph data-line-178">
<p>Tuples can be destructured(splitted) using patter matching and can be accessed using period “.”. E.g:</p>
</div>
<div class="listingblock data-line-179">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> tup: (<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">f64</span>, <span class="hljs-built_in">u8</span>) = (<span class="hljs-number">500</span>, <span class="hljs-number">6.4</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">let</span> five_hundred = tup.<span class="hljs-number">0</span>;
<span class="hljs-keyword">let</span> six_point_four = tup.<span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> one = tup.<span class="hljs-number">2</span>;</code></pre>
</div>
</div>
<div class="paragraph data-line-186">
<p><strong>Shadowing:</strong></p>
</div>
<div class="paragraph data-line-188">
<p>Shadowing let us reuse variables with same name, rather than forcing 
us to create two unique variables. The second variable’s value is what 
appears when the variable is used. It’s also possible to change the type
 of the variable since we’re effectively creating a new variable. E.g.</p>
</div>
<div class="listingblock data-line-190">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> word = “Hello”; 	<span class="hljs-comment">//word is type string slice (&amp;str)</span>
<span class="hljs-keyword">let</span> word = word.len();   	<span class="hljs-comment">//word is type usize with value 5</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-194">
<h3 id="truestrings">2.3. Strings</h3>
<div class="paragraph data-line-195">
<p>The <span class="blue"><strong>String</strong></span> type is the most common type that has ownership over his contents, it’s growable and <span class="blue">UTF-8 encoded</span>,
 so it has a variable length that range from 1 and up to 6 bytes(the 8 
in UTF-8 refers to the size of the code unit, which is 8 bits. For 
UTF-16 its 16 bits and so on). Rust ensure this and panics if you try to
 put invalid UTF-8 symbols).</p>
</div>
<table class="tableblock frame-all grid-all stretch data-line-199">
<caption class="title">Table 5. UTF-8 (1993)[2]. (x represents data)*</caption>
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1112%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">#of Bytes</th>
<th class="tableblock halign-left valign-top">First code point</th>
<th class="tableblock halign-left valign-top">Last code point</th>
<th class="tableblock halign-left valign-top">Byte 1</th>
<th class="tableblock halign-left valign-top">Byte 2</th>
<th class="tableblock halign-left valign-top">Byte 3</th>
<th class="tableblock halign-left valign-top">Byte 4</th>
<th class="tableblock halign-left valign-top">Byte 5</th>
<th class="tableblock halign-left valign-top">Byte 6</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+0000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+007F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xxxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+0080</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+07FF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">110xxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+0800</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+FFFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1110xxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+10FFFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11110xxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+200000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+3FFFFFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">111110xx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+4000000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+7FFFFFFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1111110x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-210">
<p>Memory is requested from the memory allocator at <span class="red">runtime</span> and returned(drop) via ownership system. To create a String(mutable) from a <span class="underline"><strong>string literal</strong></span>(immutable, known and hardcoded into de executable at compile time (string literals are inside “” symbol)):</p>
</div>
<div class="listingblock data-line-212">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"hello"</span>); 	<span class="hljs-comment">//creates a String from a string literal “hello”</span>
s.push_str(<span class="hljs-string">", world!"</span>); 		<span class="hljs-comment">// push_str() appends a literal to a String</span>
<span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, s);			 <span class="hljs-comment">// This will print `hello, world!`</span></code></pre>
</div>
</div>
<div class="paragraph data-line-217">
<p>Strings are implemented as a Collection of bytes, plus some methods 
that provide functionality to those bytes when interpreted as text. Rust
 has ONLY ONE string type in the core language which is <span class="red">STRING SLICE</span>
 (str); the String type is provided as part of Rusts Standard Library 
rather than the core. However, both, String and str are UTF-8 encoded.</p>
</div>
<div class="paragraph data-line-219">
<p><span class="red">Indexing isn’t allowed</span> on Strings because 
UTF-8 symbols may take more than 1 byte so, invalid character may show 
up if we tried to return only 1 byte as the following example:</p>
</div>
<div class="listingblock data-line-220">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"♥"</span>);
<span class="hljs-keyword">let</span> h = s1[<span class="hljs-number">0</span>];	 <span class="hljs-comment">// Rust doesn’t compile indexing on Strings</span>
<span class="hljs-comment">//However, if you really want to use indexing, you can use string slices using the range of the slice. Note that this indexing MUST occur at UTF-8 valid characters boundaries so you cannot just read 1 byte of the multibyte heart emoji(3 bytes).</span>
<span class="hljs-keyword">let</span> len = s1.len();
<span class="hljs-keyword">let</span> indexing = &amp;s1[<span class="hljs-number">0</span>..len];</code></pre>
</div>
</div>
<div class="paragraph data-line-228">
<p><strong>Iterating Over Strings</strong></p>
</div>
<div class="paragraph data-line-230">
<p>Since indexing Strings is out of the table, the recommendation is to access elements as char or bytes.</p>
</div>
<table class="tableblock frame-all grid-all stretch data-line-234">
<caption class="title">Table 6. Interpreting Strings</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">As chars</th>
<th class="tableblock halign-left valign-top">As bytes</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">for c in "न म स्ते".chars() {print!("{}", c);	//  न म स स्ते</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">for b in "न म स्ते".bytes() {println!("{},", b);         // 224,164..135</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-240">
<p>Strings are hard because: propensity for exposing errors in compile 
time, complicated structure, and UTF-8. But this will prevent you from 
having to handle errors involving non-ASCII characters.</p>
</div>
<div class="sect3 data-line-242">
<h4 id="trueslice_typecommonly_used_as_str">2.3.1. Slice Type(commonly used as &amp;str)</h4>
<div class="paragraph data-line-243">
<p>At the most basic, a slice is a pointer to a block of memory. Slices 
let you reference a contiguous sequence of elements in a collection 
rather than the whole collection(for example a part of an array or 
vector).</p>
</div>
<div class="paragraph data-line-245">
<p>A String slice(&amp;str) can be a reference pointing to an specific 
point of the binary(string literal) or a reference to part of a 
String(heap). So, <span class="blue">String slices</span> allows indexing on <span class="green">Strings or string literals</span>, however, they must occur at valid UTF-8 character boundaries. Slice method <span class="blue">from</span> in String tracks a starting and an ending index. E.g.</p>
</div>
<div class="listingblock data-line-246">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"hello world"</span>);
<span class="hljs-keyword">let</span> hello = &amp;s[<span class="hljs-number">0</span>..<span class="hljs-number">5</span>];
<span class="hljs-keyword">let</span> world = &amp;s[<span class="hljs-number">6</span>..<span class="hljs-number">11</span>];</code></pre>
</div>
</div>
<div class="paragraph data-line-251">
<p>Slice Program: write a function that takes a string and returns the first word it finds in that string</p>
</div>
<div class="listingblock data-line-252">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">first_word</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; &amp;<span class="hljs-built_in">str</span> {
<span class="hljs-keyword">let</span> bytes = s.as_bytes();		<span class="hljs-comment">// Convert our String to an array of bytes</span>
<span class="hljs-comment">/* iter is a method that returns each element in a collection and that enumerate wraps the result of iter and returns each element as part of a tuple instead */</span>
    <span class="hljs-keyword">for</span> (i, &amp;item) <span class="hljs-keyword">in</span> bytes.iter().enumerate() {
        <span class="hljs-keyword">if</span> item == <span class="hljs-string">b' '</span> {  		<span class="hljs-comment">//search for byte that represents the “space” (this uses byte literal).</span>
            <span class="hljs-keyword">return</span> &amp;s[<span class="hljs-number">0</span>..i]; }  }
    &amp;s[..] }</code></pre>
</div>
</div>
<div class="paragraph data-line-262">
<p><strong>The advantage of using slices</strong></p>
</div>
<div class="ulist data-line-264">
<ul>
<li class="data-line-264">
<p>Validity is ensured by lifetimes: since its referencing memory, the memory must be valid so its safer than Strings.</p>
</li>
<li class="data-line-265">
<p>Borrowing rules apply: so no data races occur.</p>
</li>
<li class="data-line-266">
<p>More generic data type: it can reference string literals or Strings so its widely used in APIs.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-268">
<h4 id="truetwo_types_of_strings_string_vs_str_and_the_implications_of_not_having_this_on_c_language">2.3.2. Two types of strings: String vs %str (and the implications of not having this on C language)</h4>
<div class="paragraph data-line-269">
<p><a href="https://fasterthanli.me/blog/2020/working-with-strings-in-rust/" class="bare">https://fasterthanli.me/blog/2020/working-with-strings-in-rust/</a></p>
</div>
<div class="paragraph data-line-271">
<p>Basically, this article says that in Rust, <span class="green">String</span> type values are always UTF-8 valid symbols because you get an error otherwise. It is heap-allocated.
&amp;str refer to data from anywhere: heap, stack or even program’s data segment.</p>
</div>
<div class="paragraph data-line-274">
<p><strong>The implications of not having String on C</strong></p>
</div>
<div class="paragraph data-line-276">
<p>By comparison, <span class="red">C has no string type. It doesn’t even have a real character type</span>. C char is.. an ASCII character plus an additional bit - effectively, <span class="red">it’s just a signed 8-bit integer: int8_t</span>.</p>
</div>
<div class="ulist data-line-278">
<ul>
<li class="data-line-278">
<p>There is absolutely <span class="red">no guarantee that anything in a char* is a valid UTF-8</span>,
 or a valid something for that matter. There is no encoding associated 
to a char*, which is just an address in memory. There is <span class="red">no length</span> associated to it either, so computing its length involves finding the null terminator.</p>
</li>
<li class="data-line-279">
<p>Null-terminated strings are also a serious security concern. Not to 
mention that NULL is a valid Unicode character, so null-terminated 
strings cannot represent all valid UTF-8 strings.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2 data-line-281">
<h3 id="trueoperators">2.4. Operators</h3>
<div class="paragraph data-line-282">
<p>--mut:  Assigns mutable (modifiable, non-static content) attribute. 
In Rust variables are immutable by default to enforce safety and easy 
concurrency. E.g.:</p>
</div>
<div class="listingblock data-line-283">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> guess = <span class="hljs-number">5</span>;
<span class="hljs-keyword">match</span> number1.cmp(&amp;number2) {
    Ordering::Less =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Number 1 is smaller"</span>),
    Ordering::Greater =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Number 1 is larger!"</span>),
	_ =&gt; (), 			<span class="hljs-comment">//The “_” pattern will match any value.</span></code></pre>
</div>
</div>
<div class="paragraph data-line-290">
<p><strong>--match</strong>: allows us to compare a value against a 
series of patterns and then execute code based on which pattern matches.
 E.g. comparing returns an Ordering enum with 3 possible values: Less, 
Greater, Equal. Note that match is exhausting so all cases must be 
handled ( in case you want to handle remaining cases “_” place holder is
 a useful to match any pattern)</p>
</div>
<div class="paragraph data-line-292">
<p><strong>--const</strong>: constants are ALWAYS immutable. 
Furthermore, constants require annotated type and can only be set to a 
constant expression computed in compile time. <code>const MAX_POINTS: u32 = 100_000;		//100,000</code>
In Rust, constants use all upercase with underscores. Also, underscores 
can be inserted in numeric literals to improve readability.</p>
</div>
</div>
<div class="sect2 data-line-296">
<h3 id="truefunctions_methods">2.5. Functions &amp; Methods</h3>
<div class="sect3 data-line-297">
<h4 id="truefunctions">2.5.1. Functions</h4>
<div class="paragraph data-line-299">
<p>Rust doesn’t care where you define your functions, only that they’re 
defined somewhere (unlike C, where you must define a function before use
 it).
In function signatures, you must declare the type of each parameter, 
this means in the annotated form. E.g.</p>
</div>
<div class="listingblock data-line-301">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example_function</span></span>(x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span>) {
    <span class="hljs-built_in">println!</span>(“value of x is: {}”, x) …}</code></pre>
</div>
</div>
<div class="paragraph data-line-305">
<p><strong>Functions with returning values:</strong></p>
</div>
<div class="paragraph data-line-307">
<p>Return type goes after an arrow (→). Functions can return early by 
using the return keyword and specifying a value, but most functions 
return the last expression implicitly, by not adding semicolon (this 
means that this is the return value expression).</p>
</div>
<div class="listingblock data-line-308">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">plus_one</span></span>(x: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span> { x + <span class="hljs-number">1</span>  }		<span class="hljs-comment">//no semicolon, so it returns x + 1</span>
plus_one(<span class="hljs-number">5</span>); 	<span class="hljs-comment">//6</span></code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-312">
<h4 id="truemethods">2.5.2. Methods</h4>
<div class="paragraph data-line-313">
<p>Methods are similar to functions, they can have parameters, return value</p>
</div>
<div class="paragraph data-line-315">
<p><code>object::method()</code> → "method" is an associated function of
 an object type (static method). “::” is like namespace where 2 methods 
equally named are totally different if they namespace is different. E.g:</p>
</div>
<div class="listingblock data-line-316">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> guess = <span class="hljs-built_in">String</span>::new();		<span class="hljs-comment">//method that creates a new instance of a String</span>
instance::method.submethod() -&gt; Calls sub-method on method handle. E.g.: io::stdin().read_line();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-320">
<h3 id="truefailures">2.6. Failures</h3>
<div class="paragraph data-line-321">
<p><span class="blue">Result</span> types are enumerations. For Result, 
the variants are Ok or Err. The Ok variant indicates the operation was 
successful, and inside Ok is the successfully generated value. The Err 
variant means the operation failed and Err contains information about 
how or why the operation failed. The purpose of these Result types is to
 encode error-handling information.</p>
</div>
<div class="paragraph data-line-323">
<p><code>E.g.: func().expect(“failed”)</code> → <span class="blue">expect</span> Unwraps a result, yielding the content of an Ok. Otherwise panics and includes message and content of Err.</p>
</div>
</div>
<div class="sect2 data-line-325">
<h3 id="truescope">2.7. Scope {}</h3>
<div class="paragraph data-line-326">
<p>A scope is the range within a program for which an item is valid.</p>
</div>
</div>
<div class="sect2 data-line-328">
<h3 id="trueloops">2.8. Loops</h3>
<table class="tableblock frame-all grid-all stretch data-line-333">
<caption class="title">Table 7. Loops</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">For</th>
<th class="tableblock halign-left valign-top">While</th>
<th class="tableblock halign-left valign-top">Loop</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Increased
  safety of the code and eliminated the chance of bugs that might result
 from going beyond the end of the array or not going far enough and 
missing some items.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Useful
 to evaluate a condition within a loop. However, is slower because the 
compiler adds runtime code to perform the conditional check on every 
element on every iteration through the loop.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Executes a block of code over and over again forever or until you explicitly tell it to stop.</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">let a = [10, 20, 30, 40, 50];</p>
<p class="tableblock">for element in a.iter() {</p>
<p class="tableblock">println!("the value is: {}", element);}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">let mut number = 3;</p>
<p class="tableblock">while number != 0 {</p>
<p class="tableblock">println!("{}!", number); number -= 1; }</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">loop {println!("again!";}</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-351">
<p>Note: Loops can return a value with the break statement</p>
</div>
<div class="listingblock data-line-352">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs">Let result = <span class="hljs-keyword">loop</span> {
    counter += <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> counter == <span class="hljs-number">10</span> {
        <span class="hljs-keyword">break</span> counter * <span class="hljs-number">2</span>;
    }
};				<span class="hljs-comment">// the ; makes the loop a statement, assigning the counter value to result.</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-361">
<h2 id="truestack_heap">3. Stack &amp; Heap</h2>
<div class="sectionbody">
<div class="paragraph data-line-362">
<p>Stack-allocated data has a known, fixed size, LIFO.</p>
</div>
<div class="paragraph data-line-364">
<p>Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p>
</div>
<div class="paragraph data-line-366">
<p>The heap is less organized: when you put data on the heap, you 
request a certain amount of space. The operating system finds an empty 
spot in the heap that is big enough, marks it as being in use, and 
returns a pointer, which is the address of that location. This process 
is called allocating on the heap and is sometimes abbreviated as just 
allocating. Pushing values onto the stack is not considered allocating. 
Because the pointer is a known, fixed size, you can store the pointer on
 the stack, but when you want the actual data, you must follow the 
pointer.</p>
</div>
</div>
</div>
<div class="sect1 data-line-368">
<h2 id="trueownership">4. Ownership</h2>
<div class="sectionbody">
<div class="paragraph data-line-369">
<p>All programs must manage the way they use a computer’s memory while running. Some languages have <span class="underline">garbage collection</span> that constantly looks for no longer used memory as the program runs; in other languages, the programmer must explicitly <span class="underline">allocate and free the memory</span>. Rust uses a third approach: memory is managed through a <span class="green"><strong>system of ownership</strong></span>
 with a set of rules that the compiler checks at compile time. None of 
the ownership features slow down your program while it’s running.</p>
</div>
<div class="sect2 data-line-371">
<h3 id="trueownership_rules">4.1. Ownership Rules</h3>
<div class="ulist data-line-373">
<ul>
<li class="data-line-373">
<p>Each value in Rust has a variable that’s called its owner.</p>
</li>
<li class="data-line-374">
<p>There can only be one owner at a time.</p>
</li>
<li class="data-line-375">
<p>When the owner goes out of scope, the value will be dropped hence the memory is freed.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-378">
<p>Note: Ownership rules applies to variables as well as functions.</p>
</div>
</div>
<div class="sect2 data-line-380">
<h3 id="trueinteracting_with_data_move_if_heap_copy_if_stack">4.2. Interacting with data: Move if Heap, Copy if Stack.</h3>
<div class="paragraph data-line-382">
<p>Rust will <span class="red">never</span> automatically create “deep” 
copies of your heap allocated data(because could result in poor 
performance). Instead Rust performs a “move” operation, on which:</p>
</div>
<div class="ulist data-line-384">
<ul>
<li class="data-line-384">
<p>Stack-allocated Data is Copied with an internal clone.</p>
</li>
<li class="data-line-385">
<p>Heap-allocated Data copies just the reference to the same location. 
It transfers ownership! So previous variable is invalidated(avoiding 
double free problem).</p>
</li>
</ul>
</div>
<div class="paragraph data-line-387">
<p>This way, the previous owner will not try to drop memory when goes 
out of scope because it’s invalid; the new owner will now oversee the 
value dropping.</p>
</div>
<div class="paragraph data-line-389">
<p>In the next example, known size values like length and capacity are 
stored on the Stack so they are copied; dynamic values like String ptr 
data is allocated on heap so only the pointer is copied, however 
ownership is passed as shown below.</p>
</div>
<div class="listingblock data-line-390">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"hello"</span>);   <span class="hljs-comment">//String stores some values on Heap and some on Stack</span>
<span class="hljs-keyword">let</span> s2 = s1;			    <span class="hljs-comment">//s1 is now invalid for safety. Now S2 has ownership</span></code></pre>
</div>
</div>
<div class="imageblock data-line-396">
<div class="content">
<img src="index%20Archivos/2_stackheap.jpg" alt="2 stackheap">
</div>
<div class="title">Figure 2. Representation in memory after s1 has been invalidated.</div>
</div>
<table class="tableblock frame-all grid-all stretch data-line-400">
<caption class="title">Table 8. Ownership functions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pass copy</th>
<th class="tableblock halign-left valign-top">Pass ownership</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ x is created on <span class="red">stack</span></p>
<p class="tableblock">let x = 5; <br>
/ x (i32) is Copied into function
makes_copy(x); <br>
/x is still valid here</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ s is created on the <span class="red">heap</span><br>
let s = String::from("hello");<br></p>
<p class="tableblock">/s pass ownership to the function…​(MOVE operation)<br>
take_ownership(s);<br>
/s is <span class="red">no longer valid</span> here</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-421">
<p>Note: To create a deep copy, including heap data, use clone() method. <code>let s2 = s1.clone();</code></p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-423">
<h2 id="truereference_and_borrowing">5. Reference (&amp;) and borrowing</h2>
<div class="sectionbody">
<div class="paragraph data-line-424">
<p>&amp; → Get memory address: operator that gets the memory address (in hexadecimal) of a piece of data.</p>
</div>
<div class="sect2 data-line-426">
<h3 id="truethe_rules_of_references">5.1. The Rules of References</h3>
<div class="ulist data-line-427">
<ul>
<li class="data-line-427">
<p>At any given time, you can have either one mutable reference or any number of immutable references.</p>
</li>
<li class="data-line-428">
<p>References must always be valid(lifetime).</p>
</li>
<li class="data-line-429">
<p>References are immutable by default and the scope determines its validity.</p>
</li>
</ul>
</div>
</div>
<div class="sect2 data-line-431">
<h3 id="trueborrowing">5.2. Borrowing</h3>
<div class="paragraph data-line-432">
<p>It’s also possible to<strong> use a value without taking ownership</strong>,
 by using references (&amp;), we call having references as function 
parameters borrowing. The scope in which the variable is valid isn’t 
affected by the borrowing variable/function, so we don’t have to drop 
what the reference points to when it goes out of scope because we didn’t
 had ownership in the first place.</p>
</div>
<div class="listingblock data-line-433">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs">{
	<span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"hello"</span>);		<span class="hljs-comment">//s1 has ownership</span>
	<span class="hljs-keyword">let</span> len = calculate_length(&amp;s1);		<span class="hljs-comment">//len borrows s1, and uses it.</span>
						<span class="hljs-comment">// s1 keeps having ownership</span>
} 					       	 <span class="hljs-comment">//s1 goes out of scope so is freed.</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">calculate_length</span></span>(s: &amp;<span class="hljs-built_in">String</span>) -&gt; <span class="hljs-built_in">usize</span> { s.len()}</code></pre>
</div>
</div>
<div class="imageblock data-line-442">
<div class="content">
<img src="index%20Archivos/3_borrowing.jpg" alt="3 borrowing">
</div>
<div class="title">Figure 3. Variable s borrowing variable s1. These 
&amp; are references, and they allow you to refer to some value without 
taking ownership of it.</div>
</div>
<div class="paragraph data-line-444">
<p>The opposite of reference is dereference, which is accomplish with dereference operator (*) on <a href="#truesmart_pointers">Smart Pointers</a>.</p>
</div>
</div>
<div class="sect2 data-line-446">
<h3 id="truemutable_references">5.3. Mutable references</h3>
<div class="paragraph data-line-447">
<p>Note that references are immutable by default, to create a mutable reference, just add &amp;mut s trait.</p>
</div>
<div class="paragraph data-line-449">
<p>A big restriction on mutable references is that you can have only <span class="underline">ONE mutable reference</span> to a value in the <span class="underline">same scope</span>,
 also is not possible to have mutable and immutable references in the 
same scope. This restriction allows mutation in a very controlled 
fashion, avoiding race conditions, simultaneous access to the same piece
 of data, synchronization problems and sudden changes.</p>
</div>
<div class="listingblock data-line-451">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"hello"</span>);

<span class="hljs-keyword">let</span> r1 = &amp;s; 			<span class="hljs-comment">//1 immutable reference, no problem</span>
<span class="hljs-keyword">let</span> r2 = &amp;s; 			<span class="hljs-comment">//2 immutable references, no problem</span>
<span class="hljs-built_in">println!</span>(<span class="hljs-string">"{} and {}"</span>, r1, r2)  			 <span class="hljs-comment">// references to r1 and r2 will not be used after this point</span>

<span class="hljs-keyword">let</span> r3 = &amp;<span class="hljs-keyword">mut</span> s; 		<span class="hljs-comment">//1 mutable reference and no immutable ones, no problem</span></code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-461">
<h3 id="truedangling_references">5.4. Dangling references</h3>
<div class="paragraph data-line-462">
<p>if you have a reference to some data, the compiler will ensure that 
the data will not go out of scope before the reference to the data does,
 at <span class="green">compile time!</span>(using lifetimes).</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-464">
<h2 id="truestructures">6. Structures</h2>
<div class="sectionbody">
<div class="paragraph data-line-465">
<p>Like tuples, structures can group many data types together. However, 
structures doesn´t rely on data order  declaration. Structs own its data
 so data referenced by a struct is valid as long as struct is.</p>
</div>
<div class="listingblock data-line-466">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">User</span></span> {
  	 username: <span class="hljs-built_in">String</span>,
   	 email: <span class="hljs-built_in">String</span>,
   	 sign_in_count: <span class="hljs-built_in">u64</span>,
   	 active: <span class="hljs-built_in">bool</span>,
}</code></pre>
</div>
</div>
<div class="paragraph data-line-474">
<p><strong>Instance</strong></p>
</div>
<div class="paragraph data-line-476">
<p>Instances are declared using key:value pairs, luckily there is a <span class="underline">shorthand notation</span> when variables and fields have the <strong>same Name</strong>
 (email: email → email) Rust automatically assigns them. Access to a 
specific field is granted through dot notation. Entire instance should 
be mutable, Rust <span class="red">does´t allow to mark only certain fields as mutable.</span></p>
</div>
<div class="listingblock data-line-478">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">build_user</span></span>(email: <span class="hljs-built_in">String</span>, username: <span class="hljs-built_in">String</span>) -&gt; User {
    User {
        email,
        username,
        active: <span class="hljs-literal">true</span>,
        sign_in_count: <span class="hljs-number">1</span>,
    }
}
<span class="hljs-keyword">let</span> user1 = build_user(<span class="hljs-built_in">String</span>::from( “Eduardo”), <span class="hljs-built_in">String</span>::from( “Tapia”));
user1.active = <span class="hljs-literal">false</span>;</code></pre>
</div>
</div>
<div class="paragraph data-line-491">
<p><strong>Struct update syntax</strong>
It is possible to create a new instance that uses values of an existing 
one. And there is also a shorthand notation presented to set the 
remaining fields with another instance using “..” .</p>
</div>
<div class="listingblock data-line-493">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> user2 = User {
    email: <span class="hljs-built_in">String</span>::from( “etapia.clr@gmail.com”),
    username: <span class="hljs-built_in">String</span>::from( “Killerpug”),
	..user1				<span class="hljs-comment">//remaining field on user2 are the same as user1.</span>
};</code></pre>
</div>
</div>
<div class="paragraph data-line-501">
<p>Note: to update struct use dot notation. E.g: <code>user1.email = String::from(“<a href="mailto:etapia@gmail.com">etapia@gmail.com</a>”);</code>. We use String to OWN the data.</p>
</div>
<div class="sect2 data-line-503">
<h3 id="truetuple_structure">6.1. Tuple structure</h3>
<div class="paragraph data-line-505">
<p>Tuple structs have the added meaning the struct name provides, but don’t have names associated with their fields.</p>
</div>
<div class="listingblock data-line-506">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> 3<span class="hljs-title">DPoint</span></span>(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>);
<span class="hljs-keyword">let</span> origin = <span class="hljs-number">3</span>DPoint(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-510">
<h3 id="truemethods_2">6.2. Methods</h3>
<div class="paragraph data-line-511">
<p>Methods only differ from functions because they are defined within the context(<span class="blue">impl</span>) of the struct and their first parameter is always <span class="green">self</span>, which represents the instance of the struct the method is being called on.</p>
</div>
<div class="listingblock data-line-512">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">impl</span> Rectangle {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">area</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u32</span> {		<span class="hljs-comment">//add &amp;mut self if you want to modify the struct</span>
        <span class="hljs-keyword">self</span>.width * <span class="hljs-keyword">self</span>.height
    }
}
Let rect1 = Rectangle { width: <span class="hljs-number">30</span>, height:<span class="hljs-number">50</span>,};	<span class="hljs-comment">//creating a Rectangle instance</span>
Rect1.area();				<span class="hljs-comment">//calling the area method</span></code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-522">
<h3 id="trueassociated_functions">6.3. Associated functions</h3>
<div class="paragraph data-line-523">
<p>We’re allowed to define functions within impl blocks that <span class="underline">don’t take self as a parameter</span>,
 these are called associated functions(still functions, not methods). 
Associated functions are often used for constructors that will return a 
new instance of the struct. To call this associated function, use the 
namespace“::” notation. E.g.</p>
</div>
<div class="listingblock data-line-524">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">impl</span> Rectangle {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">square</span></span>(size: <span class="hljs-built_in">u32</span>) -&gt; Rectangle {		<span class="hljs-comment">//no self</span>
        Rectangle { width: size, height: size }
    }
}
  <span class="hljs-keyword">let</span> sq = Rectangle::square(<span class="hljs-number">3</span>);</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-533">
<h3 id="truederived_traits">6.4. Derived traits</h3>
<div class="paragraph data-line-534">
<p>The <span class="blue">println!</span> macro can do many kinds of 
formatting, and by default, the curly brackets tell println! to use 
formatting known as Display (output intended for direct end user 
consumption). For primitive types we’ve seen so far there’s only one way
 you’d want to show them. But <strong>with structs</strong>, <span class="underline">the way println! should format the output is less clear because there are <strong>more display possibilities</strong></span>:
 Do you want commas or not? Do you want to print the curly brackets? 
Should all the fields be shown? Due to this ambiguity, Rust doesn’t try 
to guess what we want, and <span class="red">structs don’t have a provided implementation of Display.</span></p>
</div>
<div class="listingblock data-line-535">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-built_in">println!</span>(<span class="hljs-string">"rect1 is {:?}"</span>, rect1);</code></pre>
</div>
</div>
<div class="paragraph data-line-538">
<p>Putting the specifier <strong>:?</strong> inside the curly brackets tells println! we want to use an output format called Debug. The <strong>Debug trait</strong>
 enables us to print our struct in a way that is useful for developers 
so we can see its value while we’re debugging our code.
Rust does include functionality to print out debugging information, but 
we have to explicitly make that functionality available for our struct. 
To do that, we add the annotation #[derive(Debug)] just before the 
struct definition.</p>
</div>
<div class="listingblock data-line-540">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Rectangle</span></span> {
    width: <span class="hljs-built_in">u32</span>,
    height: <span class="hljs-built_in">u32</span>,
}
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> rect1 = Rectangle { width: <span class="hljs-number">30</span>, height: <span class="hljs-number">50</span> };
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"rect1 is {:?}"</span>, rect1);
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-552">
<h3 id="truewheres_the_operator">6.5. Where’s the → Operator?</h3>
<div class="paragraph data-line-553">
<p>In C and C++, two different operators are used for calling methods: 
you use “.” if you’re calling a method on the object directly and → if 
you’re calling the method on a pointer to the object and need to 
dereference the pointer first. In other words, if object is a pointer, 
object→something() is similar to (*object).something().</p>
</div>
<div class="paragraph data-line-555">
<p>Rust doesn’t have an equivalent to the → operator; instead, Rust has a feature called <span class="green"><strong>automatic referencing and dereferencing</strong></span>.
 Here’s how it works: when you call a method with object.something(), 
Rust automatically adds in &amp;, &amp;mut, or * so object matches the 
signature of the method. In other words, the following are the same:  <code>p1.distance(&amp;p2);  ==   (&amp;p1).distance(&amp;p2);</code></p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-557">
<h2 id="trueenums_and_pattern_matching">7. Enums and pattern matching</h2>
<div class="sectionbody">
<div class="paragraph data-line-558">
<p>Enumerators allow us to enumerate all possibilities but only choosing
 one. It has some properties of structs as all variants should be 
treated as the same type, and enums also can have associated method and 
functions.</p>
</div>
<div class="listingblock data-line-559">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-comment">//Simple Enum and usage</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">IpAddrKind</span></span> {
    V4,
    V6,
}
<span class="hljs-keyword">let</span> four = IpAddrKind::V4;
<span class="hljs-keyword">let</span> six = IpAddrKind::V6;
<span class="hljs-comment">// Note that the variants of the enum are namespaced under its identifier, allowing either: V4 or V6.</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">route</span></span>(ip: IpAddrKind) { }


<span class="hljs-comment">//Data embedded in the Enum(using tuple)</span>
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">IpAddr</span></span> {
    V4(<span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u8</span>, <span class="hljs-built_in">u8</span>),
    V6(<span class="hljs-built_in">String</span>),
}
<span class="hljs-keyword">let</span> home = IpAddr::V4(<span class="hljs-number">192</span>, <span class="hljs-number">168</span>, <span class="hljs-number">50</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">let</span> loopback = IpAddr::V6(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"::1"</span>));
<span class="hljs-comment">// Note: you can put any kind of data inside an enum variable, even a struct or another enum.</span></code></pre>
</div>
</div>
<div class="paragraph data-line-582">
<p><strong>Using methods and associated functions on Enums</strong></p>
</div>
<div class="paragraph data-line-584">
<p>Just as we’re able to define methods on structs using <span class="blue">impl</span>, we’re also able to define methods on enums. E.g.</p>
</div>
<div class="listingblock data-line-585">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Message</span></span> {
    Quit,
    Move { x: <span class="hljs-built_in">i32</span>, y: <span class="hljs-built_in">i32</span> },
    Write(<span class="hljs-built_in">String</span>),
    ChangeColor(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>, <span class="hljs-built_in">i32</span>),
}

<span class="hljs-keyword">impl</span> Message {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">call</span></span>(&amp;<span class="hljs-keyword">self</span>) {
        <span class="hljs-comment">// method body would be defined here</span>
    }
}

<span class="hljs-keyword">let</span> m = Message::Write(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"hello"</span>));		<span class="hljs-comment">//::Write is namespaced in Message enum</span>
m.call();</code></pre>
</div>
</div>
<div class="sect2 data-line-603">
<h3 id="trueoption_enum_vs_null">7.1. Option enum vs Null</h3>
<div class="paragraph data-line-604">
<p>The concept that null is trying to express is a useful one: <span class="underline">a null is a value that is currently invalid or absent for some reason</span>. Despite being <span class="red">implemented poorly on C</span>,
 where a null has led to innumerable errors, vulnerabilities, and system
 crashes. The problem with null values is that if you try to use a null 
value as a not-null value, you’ll get an error of some kind. This null 
property is pervasive because it’s extremely easy to make this kind of 
error.</p>
</div>
<div class="paragraph data-line-606">
<p>The problem radicates on the implementation. Rust <strong>does not have nulls</strong>, but it does have an enum that can encode the concept of a value being present or absent. This enum is <span class="green"><strong>Option&lt;T&gt;</strong></span>, and it is defined by the standard library(prelude) as follows:</p>
</div>
<div class="listingblock data-line-607">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Option</span></span>&lt;T&gt; {
    <span class="hljs-literal">Some</span>(T),
    <span class="hljs-literal">None</span>,
}
<span class="hljs-keyword">let</span> some_string = <span class="hljs-literal">Some</span>(<span class="hljs-string">"a string"</span>);		<span class="hljs-comment">//presence</span>
<span class="hljs-keyword">let</span> absent_number: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-literal">None</span>;	<span class="hljs-comment">//abscense</span></code></pre>
</div>
</div>
<div class="paragraph data-line-615">
<p>Option is better than Null because Option&lt;T&gt; and T (where T can
 be any type) are different types, the compiler won’t let us use an 
Option&lt;T&gt; value as if it were definitely a valid value. In order 
to use an Option&lt;T&gt; value, you want to have code that will <span class="green"><strong>handle</strong></span> each variant of Option Enum.</p>
</div>
<div class="listingblock data-line-616">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> y: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i8</span>&gt; = <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>);
<span class="hljs-keyword">let</span> sum = <span class="hljs-number">8</span> + y;	<span class="hljs-comment">//Will not compile. Needs to handle Option&lt;i8&gt; Enum</span></code></pre>
</div>
</div>
<div class="paragraph data-line-620">
<p>Note: Option is strong with match to handle cases. In other word, you
 have to convert Option&lt;T&gt; to a T before perform operations with 
T.</p>
</div>
</div>
<div class="sect2 data-line-622">
<h3 id="truematch">7.2. match</h3>
<div class="paragraph data-line-623">
<p><span class="blue">match</span> is a control flow operator that 
allows you to compare a value against a series of patterns and then 
execute code based on which pattern matches. Patterns can be made up of 
literal values, variable names, wildcards and more. The power of match 
comes from the expressiveness of patterns and the fact that the 
compilers is exhaustive (ALL CASES MUST BE HANDLED).</p>
</div>
<div class="listingblock data-line-624">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Coin</span></span> {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="hljs-built_in">u8</span> {
    <span class="hljs-keyword">match</span> coin {
        Coin::Penny =&gt; {
           Println!(“You inserted a penny”);
           <span class="hljs-number">1</span>
         }
        Coin::Nickel =&gt; <span class="hljs-number">5</span>,
        Coin::Dime =&gt; <span class="hljs-number">10</span>,
        Coin::Quarter(UsState) =&gt; <span class="hljs-number">25</span>,
    }
}
<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">UsState</span></span>{ Alaska, Alabama, ….}	<span class="hljs-comment">//remember that enums can embed data.</span></code></pre>
</div>
</div>
<div class="ulist data-line-645">
<ul>
<li class="data-line-645">
<p>⇒, separates the pattern to match and the code to run, in this case the code is just the value.</p>
</li>
<li class="data-line-646">
<p>_, wildcard that matches any value.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-648">
<p><strong>Match with Option&lt;T&gt;:</strong> function that takes an 
Option&lt;i32&gt; and, if there’s a value inside, adds 1 to that value. 
If there isn’t a value inside, the function should return the None value
 and not attempt to perform any operations.</p>
</div>
<div class="listingblock data-line-649">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">plus_one</span></span>(x: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt;) -&gt; <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">i32</span>&gt; {
    <span class="hljs-keyword">match</span> x {
        <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,
        <span class="hljs-literal">Some</span>(i) =&gt; <span class="hljs-literal">Some</span>(i + <span class="hljs-number">1</span>),
    }
}

<span class="hljs-keyword">let</span> five = <span class="hljs-literal">Some</span>(<span class="hljs-number">5</span>);
<span class="hljs-keyword">let</span> six = plus_one(five);</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-661">
<h3 id="trueif_let_concise_control_flow">7.3. if-let, concise control flow</h3>
<div class="paragraph data-line-662">
<p><span class="blue">If let</span> allows us to combine if and let into a less verbose way to handle values that <span class="underline">match only one pattern while ignoring the rest</span>.
 Using if let means less typing, less indentation, and less boilerplate 
code. However, you lose the exhaustive checking that match enforces.</p>
</div>
<table class="tableblock frame-all grid-all stretch data-line-667">
<caption class="title">Table 9. Verbose pattern-match vs if-let for 1 case</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Verbose matching pattern, only 1 case is useful</th>
<th class="tableblock halign-left valign-top">Shorthand if let</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">let some_u8_value = Some(0u8);<br>
match some_u8_value {<br>
    Some(3) ⇒ println!("three"),<br>
    _ ⇒ (),</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">let some_u8_value = Some(0u8);<br>
if let Some(3) = some_u8_value {<br>
println!("three");</p></td>
</tr>
</tfoot>
</table>
</div>
</div>
</div>
<div class="sect1 data-line-679">
<h2 id="truemanaging_growing_projects_with_packages_crates_and_modules">8. Managing growing projects with packages, crates and modules</h2>
<div class="sectionbody">
<div class="paragraph data-line-680">
<p>As a project grows, you can organize code by splitting it into 
multiple modules and then multiple files. As a package grows, you can 
extract parts into separate crates that become external dependencies.</p>
</div>
<div class="paragraph data-line-682">
<p>Once you’ve implemented an operation, other code can call that code 
via the code’s public interface without knowing how the implementation 
works.</p>
</div>
<div class="paragraph data-line-684">
<p>Rust has features that allow you to manage your code’s organization, 
including which details are exposed(public), which details are private, 
and what names are in each scope in your programs. These features, 
sometimes collectively referred to as the module system, include:</p>
</div>
<div class="ulist data-line-686">
<ul>
<li class="data-line-686">
<p>Packages: A Cargo feature that lets you build, test, and share 
crates. A package can contain multiple binary crates and at most one 
library crate.</p>
</li>
<li class="data-line-687">
<p>Crates: A tree of modules that produces a library or executable</p>
</li>
<li class="data-line-688">
<p>Modules and use: blocks that let you control the organization, scope, and privacy of paths(private/public)</p>
</li>
<li class="data-line-689">
<p>Paths: A way of naming an item, such as a struct, function, or module</p>
</li>
</ul>
</div>
<div class="sect2 data-line-691">
<h3 id="truepackages_and_crates">8.1. Packages and crates</h3>
<div class="paragraph data-line-692">
<p>When we create a new project via cargo new, Cargo creates the <span class="blue"><strong>Cargo.toml file giving us a package</strong></span>. there’s no mention of src/main.rs because Cargo follows a convention that <span class="blue"><strong>src/main.rs is the crate root of a binary</strong></span> crate with the same name as the package. Likewise, Cargo knows that <span class="green"><strong>if the package directory contains src/lib.rs, the package contains a library crate</strong></span>
 and  src/lib.rs is its crate root. Cargo passes the crate root files to
 rustc to build the library or binary. Finally because crates are 
namespaced, which means that they have their own scope so no confusion 
of which library function is being called.</p>
</div>
</div>
<div class="sect2 data-line-694">
<h3 id="truedefining_modules_to_control_scope_and_privacy">8.2. Defining modules to control scope and privacy</h3>
<div class="paragraph data-line-695">
<p>To structure our crate, rust allows organization via nested modules, 
which improves readability because programmers can find definitions 
based on groups rather than having to reading all definitios. E.g: The <span class="underline">restaurant library</span>. In the restaurant industry, some parts of a restaurant are referred to as <span class="underline">front of house(public)</span> and others as <span class="underline">back of house(private)</span>.</p>
</div>
<div class="paragraph data-line-697">
<p>Front of house is where customers are, this is where hosts seat 
customers, servers take orders and payment, and bartenders make drinks. 
Back of house is where the chefs and cooks work in the kitchen, 
dishwashers clean up, and managers do administrative work.
 Create a new library named restaurant by running <code>cargo new --lib restaurant;</code>. Then define the module as:</p>
</div>
<div class="listingblock data-line-699">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-comment">// crate lib.rs</span>
<span class="hljs-keyword">mod</span> front_of_house {
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting {
        <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add_to_waitlist</span></span>() {}	<span class="hljs-comment">//Making the module public doesn’t make the contents public</span>
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">seat_at_table</span></span>() {}	<span class="hljs-comment">//private by default</span>
    }

    <span class="hljs-keyword">mod</span> serving {
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">take_order</span></span>() {}
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">serve_order</span></span>() {}
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">take_payment</span></span>() {}
    }
}
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">eat_at_restaurant</span></span>() {
    <span class="hljs-comment">// Absolute path</span>
    crate::front_of_house::hosting::add_to_waitlist();

    <span class="hljs-comment">// Relative path</span>
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
</div>
</div>
<div class="imageblock data-line-722">
<div class="content">
<img src="index%20Archivos/tree-view.png" alt="tree view">
</div>
</div>
<div class="paragraph data-line-734">
<p>Note: Src/main.rs and src/lib.rs are called crate roots because the 
contents of these two form the root of the crate module tree. Modules 
are like filesystem’s directory tree on a computer.</p>
</div>
<div class="paragraph data-line-736">
<p><strong>Privacy</strong></p>
</div>
<div class="paragraph data-line-738">
<p>The way privacy works in Rust is that all items (functions, methods, 
structs, enums, modules, and constants) are private by default, which 
hides the inner implementation details and allow to control inner and 
outer code.
Pub keyword makes items public to the ancestor module.
Example:</p>
</div>
<div class="listingblock data-line-741">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">mod</span> back_of_house {
    <span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Breakfast</span></span> {		<span class="hljs-comment">//pub doesn’t make the fields in the structure public, (enums in contrast do)</span>
        <span class="hljs-keyword">pub</span> toast: <span class="hljs-built_in">String</span>,
        seasonal_fruit: <span class="hljs-built_in">String</span>,		<span class="hljs-comment">// seasonal_fruit is still private</span>
    }

    <span class="hljs-keyword">impl</span> Breakfast {				<span class="hljs-comment">//method associated to Breakfast structure</span>
        <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">summer</span></span>(toast: &amp;<span class="hljs-built_in">str</span>) -&gt; Breakfast {
            Breakfast {
                toast: <span class="hljs-built_in">String</span>::from(toast),
                seasonal_fruit: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"peaches"</span>),
            }
        }
    }
}

<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">eat_at_restaurant</span></span>() {
    <span class="hljs-comment">// Order a breakfast in the summer with Rye toast</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> meal = back_of_house::Breakfast::summer(<span class="hljs-string">"Rye"</span>);
    <span class="hljs-comment">// Change our mind about what bread we'd like</span>
    meal.toast = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Wheat"</span>);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"I'd like {} toast please"</span>, meal.toast);

    <span class="hljs-comment">// The next line won't compile if we uncomment it; we're not allowed</span>
    <span class="hljs-comment">// to see or modify the seasonal fruit that comes with the meal because its PRIVATE</span>
    <span class="hljs-comment">// meal.seasonal_fruit = String::from("blueberries");</span></code></pre>
</div>
</div>
<div class="paragraph data-line-769">
<p><strong>Paths</strong></p>
</div>
<div class="paragraph data-line-771">
<p>To find an item in a module tree, we use paths to navigate the filesystem. A path can take two forms:</p>
</div>
<div class="ulist data-line-773">
<ul>
<li class="data-line-773">
<p>An absolute path starts from a crate root by using a crate name or a literal crate. E.g: <code>crate::front_of_house::hosting::add_to_waitlist();</code></p>
</li>
<li class="data-line-776">
<p>A relative path starts from the current module and uses self, super, or an identifier in the current module.
Use keyword brings a path into scope to use them as if they were local items. E.g:</p>
</li>
</ul>
</div>
<div class="listingblock data-line-778">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> crate::front_of_house::hosting;
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">eat_at_restaurant</span></span>(){ hosting::add_to_waitlist(); }</code></pre>
</div>
</div>
<div class="paragraph data-line-783">
<p><strong>Using multiple items</strong></p>
</div>
<div class="paragraph data-line-785">
<p>Importing multiple items like:</p>
</div>
<div class="listingblock data-line-786">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> std::cmp::Ordering;
<span class="hljs-keyword">use</span> std::io;
<span class="hljs-comment">// can be shorted as:</span>
<span class="hljs-keyword">use</span> std::{cmp::Ordering, io};</code></pre>
</div>
</div>
<div class="paragraph data-line-792">
<p>Note: Operator “ * ” specify all public items within a path.</p>
</div>
<div class="paragraph data-line-794">
<p><strong>Aliasing</strong></p>
</div>
<div class="paragraph data-line-796">
<p>As keyword allows aliasing paths to avoid conflict of 2 same named paths. E.g. <code>std::io::Result as IoResult;</code></p>
</div>
</div>
<div class="sect2 data-line-798">
<h3 id="trueexternal_packages">8.3. External packages</h3>
<div class="paragraph data-line-799">
<p>Pulling external packages from crates.io involves:</p>
</div>
<div class="olist arabic data-line-801">
<ol class="arabic">
<li class="data-line-801">
<p>Listing the packages in the Cargo.toml file</p>
</li>
<li class="data-line-802">
<p>Bring the items into scope via use keyword</p>
</li>
</ol>
</div>
<div class="paragraph data-line-804">
<p>E.g:</p>
</div>
<div class="listingblock data-line-805">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-comment">// 1. On Cargo.toml</span>
[dependencies]
rand = <span class="hljs-string">"0.5.5"</span>;

<span class="hljs-comment">// 2. On src/main.rs</span>
<span class="hljs-keyword">use</span> rand::Rng
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {<span class="hljs-keyword">let</span> secret_number = rand::thread_rng().gen_range(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>);}</code></pre>
</div>
</div>
<div class="paragraph data-line-814">
<p>Note: std is an external package but its shipped with Cargo so no need of listing it on the Cargo.toml</p>
</div>
</div>
<div class="sect2 data-line-816">
<h3 id="trueseparating_modules_into_different_files">8.4. Separating modules into different files.</h3>
<div class="paragraph data-line-817">
<p>When modules get large, you might want to separate the module with its own file. To do this:</p>
</div>
<div class="olist arabic data-line-819">
<ol class="arabic">
<li class="data-line-819">
<p>Put a <span class="red">semicolon</span> after mod front_of_house instead of a block, this tells Rust to load the contents of the module <span class="underline">from another file</span> with the same name as the module.</p>
</li>
<li class="data-line-820">
<p>Create the src/front_of_house directory and file src/front_of_house/hosting.rs to contain definitions of hosting module.</p>
</li>
</ol>
</div>
<div class="listingblock data-line-821">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-comment">// On src/lib.rs</span>
<span class="hljs-keyword">mod</span> front_of_house;
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">use</span> crate::front_of_house::hosting;

<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">eat_at_restaurant</span></span>() {
    hosting::add_to_waitlist();
}

<span class="hljs-comment">// On src/front_of_house.rs</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> hosting; <span class="hljs-comment">//declaration of module</span>

<span class="hljs-comment">// On src/front_of_house/hosting.rs</span>
	<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add_to_waitlist</span></span>() {}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-838">
<h2 id="truecommon_collections">9. Common collections</h2>
<div class="sectionbody">
<div class="paragraph data-line-839">
<p>Standard library includes data structures called collections which may contain multiple data types. <span class="green"><strong>Unlike built-in array and tuples</strong></span>, these <span class="red"><strong>collections are stored on the heap</strong>!</span>:</p>
</div>
<div class="ulist data-line-841">
<ul>
<li class="data-line-841">
<p>Vector: allows you to store a variable number of values of the same type in contiguous memory.</p>
</li>
<li class="data-line-842">
<p>String: is a collection of UTF-8 values.</p>
</li>
<li class="data-line-843">
<p>Hash map: allows you to associate a value with a particular key. It’s
 a particular implementation of the more general data structure called a
 map.</p>
</li>
</ul>
</div>
<div class="sect2 data-line-845">
<h3 id="truevectors">9.1. Vectors</h3>
<div class="sect3 data-line-846">
<h4 id="truecreating_a_new_vector">9.1.1. Creating a new vector</h4>
<div class="listingblock data-line-847">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">Vec</span>::new();	<span class="hljs-comment">//Vec&lt;T&gt;, generic so it can hold any type</span>
v.push(<span class="hljs-number">5</span>);			  	<span class="hljs-comment">// updating a vector</span>

<span class="hljs-comment">//or</span>

<span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];		<span class="hljs-comment">// macro to create vector with initial values, it infers type because we put some data.</span></code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-856">
<h4 id="truereading_elements_of_vector">9.1.2. Reading elements of vector</h4>
<div class="ulist data-line-857">
<ul>
<li class="data-line-857">
<p>Vectors are indexed by number, starting at zero.</p>
</li>
<li class="data-line-858">
<p>Two ways of accessing an element:</p>
<div class="ulist data-line-859">
<ul>
<li class="data-line-859">
<p>Using <span class="blue">&amp; and [ ]</span>, which give us a reference.</p>
</li>
<li class="data-line-860">
<p>Using “<span class="blue">get</span>” method with the index passed as an argument, which give us an <span class="blue">Option&lt;&amp;T&gt;</span></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock data-line-861">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];

<span class="hljs-comment">// Access using reference</span>
    <span class="hljs-keyword">let</span> third: &amp;<span class="hljs-built_in">i32</span> = &amp;v[<span class="hljs-number">2</span>];
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"The third element is {}"</span>, third);

<span class="hljs-comment">//Access using get</span>
    <span class="hljs-keyword">match</span> v.get(<span class="hljs-number">2</span>) {
        <span class="hljs-literal">Some</span>(third) =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"The third element is {}"</span>, third),
        <span class="hljs-literal">None</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">"There is no third element."</span>),
    }</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-876">
<h4 id="trueiterating_a_vector">9.1.3. Iterating a vector</h4>
<div class="paragraph data-line-877">
<p>We can also iterate over mutable references in order to change the elements.</p>
</div>
<div class="listingblock data-line-878">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">100</span>, <span class="hljs-number">32</span>, <span class="hljs-number">57</span>];
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &amp;v {			<span class="hljs-comment">//iterating over immutable reference</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}"</span>, i);

<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">100</span>, <span class="hljs-number">32</span>, <span class="hljs-number">57</span>];
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> &amp;<span class="hljs-keyword">mut</span> v {
        *i += <span class="hljs-number">50</span>; } 		<span class="hljs-comment">// dereference operator (*) to get to the value in i</span></code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-889">
<h4 id="trueusing_enum_and_vector_to_store_multiple_types">9.1.4. Using Enum and vector to store multiple types</h4>
<div class="paragraph data-line-891">
<p>This makes use of the property that the variants of an enum are 
defined under the SAME ENUM TYPE :OO. However the disadvantage is that <span class="red">types have to be known at compile time(even thought is stored on heap)</span> or use a trait object discussed on <a href="#trueobject_oriented_programming">Object Oriented Programming</a>.</p>
</div>
<div class="listingblock data-line-892">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">SpreadsheetCell</span></span> {
        Int(<span class="hljs-built_in">i32</span>),
        Float(<span class="hljs-built_in">f64</span>),
        Text(<span class="hljs-built_in">String</span>),
    }

    <span class="hljs-keyword">let</span> row = <span class="hljs-built_in">vec!</span>[
        SpreadsheetCell::Int(<span class="hljs-number">3</span>),
        SpreadsheetCell::Text(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"blue"</span>)),
        SpreadsheetCell::Float(<span class="hljs-number">10.12</span>),</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-905">
<h3 id="truehash_maps">9.2. Hash Maps</h3>
<div class="paragraph data-line-906">
<p>Hash maps are useful to look up data without using idex, but keys. Iterators may also be used to generate keys easily.</p>
</div>
<div class="listingblock data-line-907">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> std::collections::HashMap;

<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> scores = HashMap::new();

scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Blue"</span>), <span class="hljs-number">10</span>);
scores.insert(<span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Yellow"</span>), <span class="hljs-number">50</span>);

<span class="hljs-keyword">for</span> (key, value) <span class="hljs-keyword">in</span> &amp;scores {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{}: {}"</span>, key, value);
    }</code></pre>
</div>
</div>
<div class="sect3 data-line-919">
<h4 id="trueupdating_a_hash_map">9.2.1. Updating a Hash Map</h4>
<div class="paragraph data-line-920">
<p>Although the number of key-values is growable, each key can ONLY have
 ONE VALUE associated at any time. You can handle collisions in three 
ways:</p>
</div>
<table class="tableblock frame-all grid-all stretch data-line-924">
<caption class="title">Table 10. Collision handling in hash maps</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">insert</th>
<th class="tableblock halign-left valign-top">or_insert</th>
<th class="tableblock halign-left valign-top">combination</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(default) Overwriting value. Using insert().</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Only updating value if key has no value. Using or_insert().</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Updating a value based on Old value. Take the previous value and run an expression/operation using it.</p></td>
</tr>
</tfoot>
</table>
<div class="admonitionblock note data-line-930">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph data-line-931">
<p><strong>Hashing function</strong></p>
</div>
<div class="paragraph data-line-933">
<p>By default, HashMap uses a “cryptographically strong” hashing function called Blake(see Blake (edit: updated to sipHash) <a href="https://www.131002.net/siphash/siphash.pdf">updated to SipHash</a>.
 Provides resistance to DoS attacks, but its tradeoff for security drops
 a little speed. However, it can be changed for a different hasher using
 BuildHasher trait.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-938">
<h2 id="trueerror_handling">10. Error Handling</h2>
<div class="sectionbody">
<div class="paragraph data-line-939">
<p>Rust divides errors(Rust doesn’t have exceptions) into 2 categories:</p>
</div>
<div class="ulist data-line-941">
<ul>
<li class="data-line-941">
<p>Recoverable errors: its reasonable to report the problem to the user and retry the operation. it uses <span class="blue">Result&lt;T, E&gt;</span> enum</p>
</li>
<li class="data-line-942">
<p>Unrecoverable errors: symptoms of bugs, like trying to access a location beyond the end of an array. It uses <span class="blue">panic!</span> Macro to print a failure message, unwind and clean up the stack, finally exiting the program.</p>
</li>
</ul>
</div>
<div class="exampleblock data-line-944">
<div class="content">
<div class="paragraph data-line-945">
<p>Errors can be expanded using --explain parameter or  using --verbose.</p>
</div>
</div>
</div>
<div class="sect2 data-line-949">
<h3 id="trueunrecoverable_errors_with_panic">10.1. Unrecoverable errors with panic!</h3>
<div class="paragraph data-line-950">
<p>A full <span class="blue">panic!</span> Unwinds and cleans the stack. Alternatively, Rust can just use <span class="blue">abort</span> profile(panic = ‘abort’) which ends the program without cleaning the stack to speed up the process and reduce binary size.</p>
</div>
<div class="paragraph data-line-952">
<p><strong>Backtracing a panic!, and its C counterpart</strong></p>
</div>
<div class="paragraph data-line-954">
<p>Lets use an accessing out-of-bound element.
In C, attempting to read beyond the end of data structure results in <span class="underline">undefined behavior</span>. You might get whatever is at the location in memory(buffer overread which leads to security vulnerabilities),</p>
</div>
<div class="paragraph data-line-957">
<p>In Rust, the execution <span class="underline">panics</span>. The 
error points at the slice(libcore/slice/mod.rs)  implementation of Rust 
source code and backtraces from there(shows all the function calls up to
 that point).</p>
</div>
</div>
<div class="sect2 data-line-959">
<h3 id="truerecoverable_errors_with_result">10.2. Recoverable errors with Result</h3>
<div class="paragraph data-line-960">
<p>Most errors aren’t serious enough to require executing exit. For 
example, trying to open a file is better to recover from it by using <span class="blue">Result&lt;T, E&gt;</span> enum:</p>
</div>
<div class="listingblock data-line-961">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> std::fs::File;
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> f = File::open(<span class="hljs-string">"hello.txt"</span>);

    <span class="hljs-keyword">let</span> f = <span class="hljs-keyword">match</span> f {
        <span class="hljs-literal">Ok</span>(file) =&gt; file,	<span class="hljs-comment">//when result is Ok, return the inner file value of the Ok</span>
        <span class="hljs-literal">Err</span>(error) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Problem opening the file: {:?}"</span>, error),
    };
}</code></pre>
</div>
</div>
<div class="paragraph data-line-973">
<p><strong>Matching Different Errors</strong></p>
</div>
<div class="paragraph data-line-975">
<p>The previous code panic in <span class="red">any</span> case. 
However, If we want to instead open a file if the failure reason was due
 to inexistence of the file and panic in any other case, then we would 
simply divide the match expression.</p>
</div>
<div class="listingblock data-line-976">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> std::fs::File;
<span class="hljs-keyword">use</span> std::io::ErrorKind;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> f = File::open(<span class="hljs-string">"hello.txt"</span>);

    <span class="hljs-keyword">let</span> f = <span class="hljs-keyword">match</span> f {
        <span class="hljs-literal">Ok</span>(file) =&gt; file, <span class="hljs-comment">//when result is Ok, return the inner file value of the Ok</span>
        <span class="hljs-literal">Err</span>(error) =&gt; <span class="hljs-keyword">match</span> error.kind() {
            ErrorKind::NotFound =&gt; <span class="hljs-keyword">match</span> File::create(<span class="hljs-string">"hello.txt"</span>) { <span class="hljs-comment">//inexisting file</span>
                <span class="hljs-literal">Ok</span>(fc) =&gt; fc, <span class="hljs-comment">// returns the recently created file</span>
                <span class="hljs-literal">Err</span>(e) =&gt; <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Problem creating the file: {:?}"</span>, e),
            },
            other_error =&gt; {
                <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Problem opening the file: {:?}"</span>, other_error)
            }
        },
    };
}</code></pre>
</div>
</div>
<div class="paragraph data-line-998">
<p>This way we can resolve for any specific or set of errors. Note that 
an error handler for create new file had to be added as it might also 
fail. That’s a lot of match!, match is very useful but also very 
primitive, see closures on <a href="#truefunctional_features_closures_and_iterators">Functional features: Closures and Iterators</a>. Closures would create something like this:</p>
</div>
<div class="listingblock data-line-999">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> f = File::open(<span class="hljs-string">"hello.txt"</span>).unwrap_or_else(|error| {
        <span class="hljs-keyword">if</span> error.kind() == ErrorKind::NotFound {
            File::create(<span class="hljs-string">"hello.txt"</span>).unwrap_or_else(|error| {
                <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Problem creating the file: {:?}"</span>, error);
            })
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">panic!</span>(<span class="hljs-string">"Problem opening the file: {:?}"</span>, error);
        }
    });
}</code></pre>
</div>
</div>
<div class="sect3 data-line-1012">
<h4 id="trueunwrap_and_expect_shortcuts_for_panic_on_error">10.2.1. ‘unwrap’ and ‘expect’: shortcuts for Panic on Error</h4>
<div class="paragraph data-line-1013">
<p><span class="blue">Unwrap</span> is a shortcut method for match-Result, <span class="underline">returns value inside Ok</span> or <span class="blue">panic!</span> in case Err.
<code>let f = File::open("hello.txt").unwrap();</code></p>
</div>
<div class="paragraph data-line-1016">
<p><span class="blue">expect</span> is similar to unwrap but let us choose the panic! error message.
<code>let f = File::open("hello.txt").expect("Failed to open hello.txt");</code></p>
</div>
<div class="paragraph data-line-1019">
<p><strong>Propagating errors</strong></p>
</div>
<div class="paragraph data-line-1021">
<p>When calls inside a function might fail, you can instead propagate 
the error to have more control over calling function. This is, return 
the error to the function whose contents has error prone calls.</p>
</div>
<div class="listingblock data-line-1022">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> std::fs::File;
<span class="hljs-keyword">use</span> std::io;
<span class="hljs-keyword">use</span> std::io::Read;
<span class="hljs-comment">// function that returns a String inside Ok or err of type ioError</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read_username_from_file</span></span>() -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">String</span>, io::Error&gt; { <span class="hljs-comment">//propagated error</span>
<span class="hljs-keyword">let</span> f = File::open(<span class="hljs-string">"hello.txt"</span>);

<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> f = <span class="hljs-keyword">match</span> f {
    <span class="hljs-literal">Ok</span>(file) =&gt; file,
    <span class="hljs-literal">Err</span>(e) =&gt; <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(e),};  			<span class="hljs-comment">//error prone call</span>

<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::new();
<span class="hljs-keyword">match</span> f.read_to_string(&amp;<span class="hljs-keyword">mut</span> s) {
    <span class="hljs-literal">Ok</span>(_) =&gt; <span class="hljs-literal">Ok</span>(s),
    <span class="hljs-literal">Err</span>(e) =&gt; <span class="hljs-literal">Err</span>(e),					<span class="hljs-comment">//error prone call</span>
}
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1043">
<p>There is also a <span class="underline">shortcut for propagating errors</span>: The <span class="blue"><strong> ? </strong></span> operator. ? operator can <span class="red">only be used on functions that return Result enum.</span></p>
</div>
<div class="listingblock data-line-1044">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> f = File::open(<span class="hljs-string">"hello.txt"</span>)?;
<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> s = <span class="hljs-built_in">String</span>::new();
f.read_to_string(&amp;<span class="hljs-keyword">mut</span> s)?;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-1050">
<h3 id="trueto_panic_or_not_to_panic">10.3. to panic! or not to panic!</h3>
<div class="paragraph data-line-1051">
<p>You can not panic when:</p>
</div>
<div class="ulist data-line-1053">
<ul>
<li class="data-line-1053">
<p>Unwrap and expect are handy when <strong>PROTOTYPING</strong>, they 
act as placeholder for when you actually decide how to handle the errors
 in a more robust way. But they are not recommended for releases because
 they just exit the program.</p>
</li>
<li class="data-line-1054">
<p>When you know result will have an Ok value its fine to use unwrap, 
basically you have more information than the compiler. For example, 
hardcoded values.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-1056">
<p>Its advisable to panic! when:</p>
</div>
<div class="ulist data-line-1058">
<ul>
<li class="data-line-1058">
<p>You could end up in a bad state(not expected).</p>
</li>
<li class="data-line-1059">
<p>Input values are not valid and you cannot encode the information 
provided by other means. However, you can ensure data validity by 
creating Custom Types : <code>pub struct Guess { value: i32, }</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1062">
<h2 id="truegeneric_types_traits_and_lifetimes">11. Generic Types, Traits and Lifetimes</h2>
<div class="sectionbody">
<div class="paragraph data-line-1063">
<p>Generics creates a definition of an abstract-generalized behavior for
 items like function signatures or structs using generic types instead 
of concrete types to reduce code duplication.</p>
</div>
<div class="paragraph data-line-1065">
<p>Traits define behavioral properties in a generic way. Traits are used with generic types to constraint types.</p>
</div>
<div class="paragraph data-line-1067">
<p>Lifetimes allow us to borrow values, while enabling the compiler to check validity of references.</p>
</div>
<div class="sect2 data-line-1070">
<h3 id="truegeneric_data_types">11.1. Generic Data Types</h3>
<div class="paragraph data-line-1071">
<p>To define a generic, the type parameter is declared before use it and inside angle brackets &lt;&gt;.</p>
</div>
<div class="listingblock data-line-1072">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs">!! <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">largest</span></span>&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T { <span class="hljs-comment">// finds biggest value inside a list</span>
	<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> largest = &amp;list[<span class="hljs-number">0</span>];
    	<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> list {
        		<span class="hljs-keyword">if</span> item &gt; largest {	<span class="hljs-comment">// Order Error: cannot compare all possible T types</span>
           	 	largest = item;}
	}
	largest
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1083">
<p><span class="red">OrderError</span>: We can only use types whose 
values can be ordered. And we don’t know if type T is able to do that so
 we have to assign the ordering property using <strong>traits</strong>.</p>
</div>
<div class="paragraph data-line-1085">
<p><strong>Performance of code using generics</strong></p>
</div>
<div class="paragraph data-line-1087">
<p>Your code doesn’t run any slower using generics than concrete types!.
 Rust accomplishes generics using monomorphization, that means that 
generic code is turned into specific code by fillling concrete types at 
compile time.</p>
</div>
</div>
<div class="sect2 data-line-1090">
<h3 id="truetraits_defining_shared_behavior">11.2. Traits: Defining shared behavior</h3>
<div class="paragraph data-line-1091">
<p>Traits are similar to a feature called <strong>Interfaces</strong>. 
Different types share the same behavior if we can call the same 
methods/functionalities on all of those types. Trait definitions are a 
way to group method signatures together to define a set of behaviors.</p>
</div>
<div class="paragraph data-line-1093">
<p><strong>Creating a Trait</strong></p>
</div>
<div class="paragraph data-line-1095">
<p>Example: You have multiple structs that holds various kinds of text 
instances: NewsArticle, Tweet and metadata(indicates type of tweet: 
retweet, reply). We want to make a media aggregator that displays all 
kinds of text. Hence, we need a to request the summary(trait) by calling
 summarize method on an instance:</p>
</div>
<div class="listingblock data-line-1096">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Summary</span></span> {		<span class="hljs-comment">//creating the Summary trait, that returns text instances</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">summarize</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span>;
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1102">
<p>After this summarize method signature, instead of providing an implementation we put a <mark>semicolon</mark>. Each type implementing this trait must <span class="underline">provide its own behavior</span>; the compiler enforces the use of summarize method.</p>
</div>
<div class="paragraph data-line-1104">
<p><strong>Implementing a Trait on a type</strong></p>
</div>
<div class="paragraph data-line-1106">
<p>To apply the Summary trait for the media aggregator, simply put the trait keyword after impl and use “<span class="blue"><strong>for</strong></span>” to specify the name of the type we want to implement the trait for.</p>
</div>
<div class="listingblock data-line-1108">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-comment">//lib.rs</span>
<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">NewsArticle</span></span> {
    <span class="hljs-keyword">pub</span> headline: <span class="hljs-built_in">String</span>,
    <span class="hljs-keyword">pub</span> location: <span class="hljs-built_in">String</span>,
    <span class="hljs-keyword">pub</span> author: <span class="hljs-built_in">String</span>,
    <span class="hljs-keyword">pub</span> content: <span class="hljs-built_in">String</span>,
}

<span class="hljs-keyword">impl</span> Summary <span class="hljs-keyword">for</span> NewsArticle {		<span class="hljs-comment">// Summary trait for article</span>

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">summarize</span> </span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span> {
        <span class="hljs-built_in">format!</span>(<span class="hljs-string">"{}, by {} ({})"</span>, <span class="hljs-keyword">self</span>.headline, <span class="hljs-keyword">self</span>.author, <span class="hljs-keyword">self</span>.location)
    }
}
<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Tweet</span></span> {
    <span class="hljs-keyword">pub</span> username: <span class="hljs-built_in">String</span>,
    <span class="hljs-keyword">pub</span> content: <span class="hljs-built_in">String</span>,
    <span class="hljs-keyword">pub</span> reply: <span class="hljs-built_in">bool</span>,
    <span class="hljs-keyword">pub</span> retweet: <span class="hljs-built_in">bool</span>,
}

<span class="hljs-keyword">impl</span> Summary <span class="hljs-keyword">for</span> Tweet {		<span class="hljs-comment">// Summary trait for tweet</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">summarize</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span> {
        <span class="hljs-built_in">format!</span>(<span class="hljs-string">"{}: {}"</span>, <span class="hljs-keyword">self</span>.username, <span class="hljs-keyword">self</span>.content)
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning data-line-1137">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph data-line-1138">
<p>One restriction to note with trait implementations is that we can implement a trait on a type <span class="red">only if either the trait or the type is local to our crate, so we know which implementation use</span>.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph data-line-1142">
<p><strong>Default implementations and override</strong></p>
</div>
<div class="paragraph data-line-1144">
<p>Override is achieved through traits, we can define a default 
implementation in a trait using brackets “{}” instead of semicolon, and 
then let the type override or maintain the default behavior.</p>
</div>
<div class="paragraph data-line-1146">
<p>Default implementations can call other methods in the same trait because they are guaranteed to be defined.</p>
</div>
<div class="listingblock data-line-1147">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Summary</span></span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">summarize</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span> {
        <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"(Read more...)"</span>)	<span class="hljs-comment">//Default implementation</span>
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1156">
<h3 id="truetraits_as_parameters">11.3. Traits as parameters</h3>
<div class="paragraph data-line-1158">
<p>Allow us to define the behavior of a parameter in a function, this 
will guarantee that a parameter behaves(implements a trait) a certain 
way so we can call certaing functions on it. Simply add <span class="blue">impl</span> keyword to the parameter:</p>
</div>
<div class="listingblock data-line-1159">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>(item: &amp;<span class="hljs-keyword">impl</span> Summary) {		<span class="hljs-comment">//item must be able to make summaries</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Breaking news! {}"</span>, item.summarize());
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1165">
<p>Or using generics:</p>
</div>
<div class="listingblock data-line-1166">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>&lt;T: Summary + Display&gt;(item: &amp;T) { 	<span class="hljs-comment">//item T type must implement summary and display</span>
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Breaking news! {}"</span>, item.summarize());
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1172">
<p>Multiple traits can be aggregated used + operator. But if there are 
many involved, the + makes it unreadable. Clauses(bounds) specify a <span class="underline">set of Traits</span> with <span class="blue">where</span> keyword.</p>
</div>
<div class="listingblock data-line-1173">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">notify</span></span>&lt;T, U&gt;(item: &amp;T, other: &amp;U) -&gt; <span class="hljs-built_in">i32</span>
    <span class="hljs-keyword">where</span> T: Summary + Display,
      U: <span class="hljs-built_in">Clone</span> + <span class="hljs-built_in">Debug</span>
{</code></pre>
</div>
</div>
<div class="paragraph data-line-1181">
<p><strong>Fixing Generic “largest” function with Traits</strong></p>
</div>
<div class="paragraph data-line-1183">
<p>Using traits, we ca ensure that items are comparable by making the generic types implement the <span class="red">PartialOrd</span> trait and items should be able to be copied(only stack located) so generic type should also implement <span class="red">Copy</span> trait.</p>
</div>
<div class="listingblock data-line-1184">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">largest</span></span>&lt;T: <span class="hljs-built_in">PartialOrd</span> + <span class="hljs-built_in">Copy</span>&gt;(list: &amp;[T]) -&gt; T {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> largest = list[<span class="hljs-number">0</span>]; 		<span class="hljs-comment">//Copy: should be able to copy/index data</span>

    <span class="hljs-keyword">for</span> &amp;item <span class="hljs-keyword">in</span> list {
        <span class="hljs-keyword">if</span> item &gt; largest {		<span class="hljs-comment">//PartialOrd: can compare values</span>
            largest = item;
        }
    }

    largest
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> number_list = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">34</span>, <span class="hljs-number">50</span>, <span class="hljs-number">25</span>, <span class="hljs-number">100</span>, <span class="hljs-number">65</span>];

    <span class="hljs-keyword">let</span> result = largest(&amp;number_list);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"The largest number is {}"</span>, result);

    <span class="hljs-keyword">let</span> char_list = <span class="hljs-built_in">vec!</span>[<span class="hljs-string">'y'</span>, <span class="hljs-string">'m'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'q'</span>];

    <span class="hljs-keyword">let</span> result = largest(&amp;char_list);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"The largest char is {}"</span>, result);
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1209">
<p>Traits can also be used to condition the implementation of method. 
For example, struct Pair only implements cmp_Display method if the inner
 type T implements PartialOrd and Display traits:</p>
</div>
<div class="listingblock data-line-1210">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> std::fmt::Display;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pair</span></span>&lt;T&gt; {
    x: T,
    y: T,
}

<span class="hljs-keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(x: T, y: T) -&gt; <span class="hljs-keyword">Self</span> {			<span class="hljs-comment">//always implemented</span>
        <span class="hljs-keyword">Self</span> { x, y }
    }
}

<span class="hljs-keyword">impl</span>&lt;T: Display + <span class="hljs-built_in">PartialOrd</span>&gt; Pair&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cmp_display</span></span>(&amp;<span class="hljs-keyword">self</span>) {			<span class="hljs-comment">//only implemented if T implements Display and PartialOrd</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.x &gt;= <span class="hljs-keyword">self</span>.y {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"The largest member is x = {}"</span>, <span class="hljs-keyword">self</span>.x);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"The largest member is y = {}"</span>, <span class="hljs-keyword">self</span>.y);
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1236">
<h3 id="truevalidating_references_with_lifetimes">11.4. Validating references with Lifetimes</h3>
<div class="paragraph data-line-1237">
<p>Every reference has a lifetime, which is the scope for which that 
reference is valid. Most of times, lifetimes are implicit and inferred 
just like types. However, sometimes, when multiple lifetimes lifespans 
are possible we must annotate lifetimes also like types.</p>
</div>
<div class="paragraph data-line-1239">
<p>Lifetimes annotations come handy to bound multiple variables to the same lifetime.</p>
</div>
<div class="paragraph data-line-1241">
<p><strong>Borrow checker</strong></p>
</div>
<div class="paragraph data-line-1243">
<p>Compares the scopes of the variables to determine whether all borrows
 are valid. Here we can see r with a lifetime ‘a and x with a lifetime 
‘b. The borrow checker determines that the lifetime of x is shorter so 
there is a dangling reference.</p>
</div>
<div class="listingblock data-line-1244">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs">!!{<span class="hljs-comment">// This code doesn’t compile because lifetime “'b” bound to variable x is no longer valid when printing r.</span>
        <span class="hljs-keyword">let</span> r;                <span class="hljs-comment">// ---------+-- 'a</span>
                              <span class="hljs-comment">//          |</span>
        {                     <span class="hljs-comment">//          |</span>
            <span class="hljs-keyword">let</span> x = <span class="hljs-number">5</span>;        <span class="hljs-comment">// -+-- 'b  |</span>
            r = &amp;x;           <span class="hljs-comment">//  |       |</span>
        }                     <span class="hljs-comment">// -+       |</span>
                              <span class="hljs-comment">//          |</span>
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"r: {}"</span>, r); <span class="hljs-comment">//          | 	//x is not valid</span>
    }                         <span class="hljs-comment">// ---------+</span></code></pre>
</div>
</div>
<div class="paragraph data-line-1256">
<p><strong>Generic lifetimes annotation</strong></p>
</div>
<div class="paragraph data-line-1258">
<p>When compiler can’t tell the lifetime inside a function, for example 
if 2 possible lifetimes are available(if-else could be one case). A 
lifetime annotation must be provided, <span class="underline">describing the relationships of the lifetimes of multiple references to each other</span>.</p>
</div>
<div class="paragraph data-line-1260">
<p>The syntax uses an apostrophe (‘) and it<strong> describes relationships of the lifetimes of multiple references to each other</strong>. For example, a function parameter with lifetime ‘a is applied to all parameters meaning that <span class="underline">all the references in the parameters and the return value must live as long as the generic lifetime.</span></p>
</div>
<div class="listingblock data-line-1261">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">longest</span></span>&lt;<span class="hljs-symbol">'a</span>&gt;(x: &amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">str</span>, y: &amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">str</span>) -&gt; &amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">str</span> {
    <span class="hljs-keyword">if</span> x.len() &gt; y.len() {
        x
    } <span class="hljs-keyword">else</span> {
        y
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1270">
<h3 id="truepredictable_lifetime_by_elision_rules">11.5. Predictable Lifetime by elision rules</h3>
<div class="paragraph data-line-1272">
<p><span class="red">Every reference needs a lifetime</span> and you 
need to specify lifetime parameters for functions or structs that use 
references. However, because certain reference-lifetime patterns are 
predictable, Rust programmers programmed patterns into Rust borrow 
checker called lifetime elision rules, they are a set of cases where the
 compiler can infer the lifetime of the reference.
The elision rules are:</p>
</div>
<div class="olist arabic data-line-1275">
<ol class="arabic">
<li class="data-line-1275">
<p><strong>Each parameter</strong> that is a reference gets its <strong>own lifetime</strong>
 parameter. In other words, a function with one parameter gets one 
lifetime parameter: fn foo&lt;'a&gt;(x: &amp;'a i32); a function with 
two parameters gets two separate lifetime parameters: fn foo&lt;'a, 
'b&gt;(x: &amp;'a i32, y: &amp;'b i32); and so on.</p>
</li>
<li class="data-line-1276">
<p>If there is exactly <span class="underline">one input lifetime parameter</span>, that lifetime is assigned to <span class="underline">all output lifetime parameters</span>: fn foo&lt;'a&gt;(x: &amp;'a i32) → &amp;'a i32.</p>
</li>
<li class="data-line-1277">
<p>if there are <strong>multiple input lifetime parameters</strong>, but one of them is &amp;self or &amp;mut self because this is a method, the lifetime of <strong>self is assigned to all output</strong> lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1279">
<p><strong>The static lifetime</strong></p>
</div>
<div class="paragraph data-line-1281">
<p>‘static is a reference that can live for the entire duration of the program.</p>
</div>
<div class="paragraph data-line-1283">
<p><strong>Generic Types, Traits and Lifetimes together</strong></p>
</div>
<div class="paragraph data-line-1285">
<p>This program returns the longer of two string slices(Lifetimes) but also prints an announcement of type T(Traits and generics)</p>
</div>
<div class="listingblock data-line-1286">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> std::fmt::Display;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">longest_with_an_announcement</span></span>&lt;<span class="hljs-symbol">'a</span>, T&gt;( x: &amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">str</span>,  y: &amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">str</span>,  ann: T) -&gt; &amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">str</span>
    <span class="hljs-keyword">where</span>
    T: Display,
{
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Announcement! {}"</span>, ann);
    <span class="hljs-keyword">if</span> x.len() &gt; y.len() {
        x
    } <span class="hljs-keyword">else</span> {
        y
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1302">
<h2 id="truewriting_automated_test">12. Writing automated test</h2>
<div class="sectionbody">
<div class="sect2 data-line-1303">
<h3 id="truehow_to_write_tests">12.1. How to write tests</h3>
<div class="paragraph data-line-1304">
<p>Test functions typically perform 3 actions:</p>
</div>
<div class="ulist data-line-1306">
<ul>
<li class="data-line-1306">
<p>Set up any needed data or state.</p>
</li>
<li class="data-line-1307">
<p>Run the code you want to test.</p>
</li>
<li class="data-line-1308">
<p>Assert the results are what you expect.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-1310">
<p>Rust offers <span class="blue">test</span> and <span class="blue">should_panic</span> attributes and macros to achieve these actions.</p>
</div>
<div class="paragraph data-line-1312">
<p><strong>Creating test functions</strong></p>
</div>
<div class="paragraph data-line-1314">
<p>To change a function into a test function, add <span class="blue">#[test]</span> before fn. Test can be run with “cargo test” command for which Rust builds a test runner <strong>special binary</strong> that contains and reports only the test annotated functions.</p>
</div>
<div class="paragraph data-line-1316">
<p><code>cargo new library_name –lib</code> → Creates a new library for test function</p>
</div>
<div class="paragraph data-line-1319">
<p><code>cargo test</code> → runs test library.</p>
</div>
<div class="listingblock data-line-1320">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-comment">// src/lib.rs</span>
<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_works</span></span>() {
        <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">2</span> + <span class="hljs-number">2</span>, <span class="hljs-number">4</span>);
    }
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch data-line-1333">
<caption class="title">Table 11. Test functions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assert_eq!(a,b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes test only if a == b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">assert_ne!(a,b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes test only if a != b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assert!(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes only if a == true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use super::*;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Brings anything written in the outer scope to the test module, to be able to use any declared function of src.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">#[test]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Converts a function into a test function</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">#[cfg(test)]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tells Rust to compile the module only when cargo test command is run.</p></td>
</tr>
</tfoot>
</table>
</div>
<div class="sect2 data-line-1344">
<h3 id="truecontrolling_how_test_are_run">12.2. Controlling how test are run</h3>
<div class="paragraph data-line-1345">
<p>You can select a single test to run or select multiple by pattern matching.</p>
</div>
<table class="tableblock frame-all grid-all stretch data-line-1349">
<caption class="title">Table 12. Test flow</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo test<br>
--test-threads = 1<br>
--show-output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defualt behavior of cargo test is to run all test In parallel, but this can be change by:<br>
--test-threads = 1 runs the test in the specified number of threads.<br>
 — show output, prints all values that where run in the test</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo test {function}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Runs single test or patterns that mathc the function names</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">#[ignore]
cargo test — --ignored</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ignore specific test that are for example very time-consuming.
runs only ignored test</p></td>
</tr>
</tfoot>
</table>
</div>
<div class="sect2 data-line-1366">
<h3 id="truetest_organization">12.3. Test organization</h3>
<div class="sect3 data-line-1367">
<h4 id="trueunit_tests">12.3.1. Unit tests</h4>
<div class="paragraph data-line-1368">
<p>Built within the module, test each unit of code in isolation. → The convention is to create a module named <span class="green"><strong>test INSIDE THE module.rs file!</strong></span> and annotate it with cfg(test) in each file that contain test functions.</p>
</div>
<div class="paragraph data-line-1370">
<p><strong>This saves compile time</strong> when you only want to build the library and <strong>saves space</strong> in the resulting compiled artifact because the tests are not included in the binary.</p>
</div>
<div class="listingblock data-line-1372">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-comment">// module.rs</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">run</span></span>(){…}	<span class="hljs-comment">//even if this is private can be tested</span>
…
<span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> test {
    <span class="hljs-keyword">use</span> super::*;	<span class="hljs-comment">//includes even private function</span>

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">test_run</span></span>() {…}</code></pre>
</div>
</div>
<div class="paragraph data-line-1383">
<p>Unit tests include even private functions.</p>
</div>
</div>
<div class="sect3 data-line-1385">
<h4 id="trueintegration_tests">12.3.2. Integration tests</h4>
<div class="paragraph data-line-1386">
<p>Integration tests are entirely external to your library. Only calls functions that are part of the <span class="green">public API</span>.
 They test coherency between parts of the library. → The convention is 
to create a tests directory at the top level of the project, next to 
src. Thes only require <span class="blue">#[test]</span>.</p>
</div>
<div class="listingblock data-line-1387">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-comment">//tests/integration_test.rs</span>
<span class="hljs-keyword">use</span> adder;	<span class="hljs-comment">//we need use keyword because “tests” is a separate crate so we need to bring adder into scope</span>

<span class="hljs-meta">#[test]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_adds_two</span></span>() {
    <span class="hljs-built_in">assert_eq!</span>(<span class="hljs-number">4</span>, adder::add_two(<span class="hljs-number">2</span>));
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1397">
<h2 id="truefunctional_features_closures_and_iterators">13. Functional features: Closures and Iterators</h2>
<div class="sectionbody">
<div class="paragraph data-line-1398">
<p>We’ll cover:</p>
</div>
<div class="ulist data-line-1400">
<ul>
<li class="data-line-1400">
<p>Closures: a function-like construct you can store in a variable</p>
</li>
<li class="data-line-1401">
<p>Iterators: a way of processing a series of elements</p>
</li>
<li class="data-line-1402">
<p>How to use these two features to improve the minigrep project</p>
</li>
<li class="data-line-1403">
<p>The performance of these two features (Spoiler alert: they’re faster than you might think!)</p>
</li>
</ul>
</div>
<div class="sect2 data-line-1405">
<h3 id="trueclosures">13.1. Closures</h3>
<div class="paragraph data-line-1406">
<p>Closures are anonymous functions you can save in a variable or pass 
as arguments to other functions. You can create the closure in one place
 and call it in a different context. Unlike functions, closures can 
capture values from the scope in which they are defined.</p>
</div>
<div class="sect3 data-line-1408">
<h4 id="trueclosures_vs_functions">13.1.1. Closures vs functions</h4>
<div class="paragraph data-line-1409">
<p>Consider we want to Implement the following behavior: we have an expensive algorithm that we want to call it <span class="underline">only once</span>
 or the least ammount of times because it consumes a lot of resources. 
We would call it only when we get new data. The expensive algorithm can 
be implemented as:</p>
</div>
<div class="paragraph data-line-1411">
<p><strong>Functions</strong></p>
</div>
<div class="paragraph data-line-1413">
<p>Implementing the expensive calculation as a function as shown below, <span class="red">executes whenever we need the result</span> of the calculation, so that isn’t of much help because if we call it multiple times (<span class="red">even with the same parameter</span>) would slow our program.</p>
</div>
<div class="listingblock data-line-1415">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">use</span> std::time::Duration;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">simulated_expensive_calculation</span></span>(intensity: <span class="hljs-built_in">u32</span>) -&gt; <span class="hljs-built_in">u32</span> {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"expensive calculation..."</span>);
    thread::sleep(Duration::from_secs(<span class="hljs-number">3</span>));
    intensity
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1425">
<p><strong>Creating and storing a closure</strong></p>
</div>
<div class="paragraph data-line-1427">
<p>Instead of always calling the function, we can define a closure and store it in a variable as follows:</p>
</div>
<div class="listingblock data-line-1429">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> std::thread;
<span class="hljs-keyword">use</span> std::time::Duration;
<span class="hljs-comment">//closures start with a pair of vertical pipes ”|”, inside which we specify the parameters of the closure.</span>
<span class="hljs-comment">//let contains the DEFINITION of an anonymous function, not the result</span>
<span class="hljs-keyword">let</span> expensive_closure = |num| {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"expensive calculation..."</span>);
        thread::sleep(Duration::from_secs(<span class="hljs-number">2</span>));
        num
    };
<span class="hljs-built_in">println!</span>(<span class="hljs-string">"Calling the closure"</span>, expensive_closure(<span class="hljs-number">43</span>));
<span class="hljs-comment">//at this point we still need to execute the expensive_closure each time we need the result but we will see on "Cache:Storing closures" how to implement memory to remember past calculations</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-1444">
<h3 id="trueclosure_features">13.2. Closure features</h3>
<div class="ulist data-line-1445">
<ul>
<li class="data-line-1445">
<p>Closures allow us to <span class="blue">define the code</span> to call at one point, store it in a variable and call it at a later point.</p>
</li>
<li class="data-line-1446">
<p>Closures do not require explicit annotations of types because they 
are not part of the user interface which requires explicit annotations 
to ensure everyone agrees on what types of values functions uses.</p>
</li>
<li class="data-line-1447">
<p>Closures are usually short and relevant only within a narrow 
context/scope so compiler is reliably able to infer parameters and 
return types.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-1449">
<p><strong>Where does the closure syntax comes from?</strong></p>
</div>
<div class="paragraph data-line-1451">
<p>Functional language use pipes, and closures syntax also derives from a
 function without annoying annotations. However, closures can be as 
annotated as functions as shown in add_one_v2 closure.</p>
</div>
<div class="listingblock data-line-1453">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span>  <span class="hljs-title">add_one_v1</span>   </span>(x: <span class="hljs-built_in">u32</span>) -&gt; <span class="hljs-built_in">u32</span> { x + <span class="hljs-number">1</span> }
<span class="hljs-keyword">let</span> add_one_v2 = |x: <span class="hljs-built_in">u32</span>| -&gt; <span class="hljs-built_in">u32</span> { x + <span class="hljs-number">1</span> };
<span class="hljs-keyword">let</span> add_one_v3 = |x|             { x + <span class="hljs-number">1</span> };
<span class="hljs-keyword">let</span> add_one_v4 = |x|               x + <span class="hljs-number">1</span>  ;</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1460">
<h3 id="truecache_storing_closures_using_generic_parameters_and_traits">13.3. Cache: Storing closures using generic parameters and traits</h3>
<div class="paragraph data-line-1461">
<p>Structs can hold closures and store results of calls to the closure. Then we can use a <span class="green"><strong>Struct as a cache</strong></span> to reduce the number of expensive_calculation executions by only executing the closure if we havent compute the result before.</p>
</div>
<div class="paragraph data-line-1463">
<p>To define Structs, we need to specify the <span class="red">type</span> of the closure, because a <span class="red">struct definition needs to know the types of each of its fields in compile time</span>.
 Each closure instance has a unique type signature; Structs, enums or 
function parameters that use closures need to use generics and trait 
bounds. Fn trait is provided by the standard library, Fn represent the 
types of parameter and return values that the closures must have to 
match this trait.</p>
</div>
<div class="listingblock data-line-1464">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-comment">// Private struct implementing closure with parameter and return type u32.</span>
<span class="hljs-comment">// This is private because we want cacher to manage the struct field rather than code.</span>
<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Cacher</span></span>&lt;T&gt;
<span class="hljs-keyword">where</span> T: <span class="hljs-built_in">Fn</span>(<span class="hljs-built_in">u32</span>) -&gt; <span class="hljs-built_in">u32</span>,		<span class="hljs-comment">//each closure instance has a unique type signature</span>
{
    calculation: T,
    cache: HashMap&lt;<span class="hljs-built_in">u32</span>, <span class="hljs-built_in">u32</span>&gt;,
}
<span class="hljs-keyword">impl</span>&lt;T&gt; Cacher &lt;T&gt;
<span class="hljs-keyword">where</span> T: <span class="hljs-built_in">Fn</span>(<span class="hljs-built_in">u32</span>) -&gt; <span class="hljs-built_in">u32</span>,
{
<span class="hljs-comment">//Cacher::new returns a Cacher instance that holds calculation-closure</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            cache: HashMap::new(),
        }
    }
<span class="hljs-comment">//we call value, whenever we need a result of expensive calculation-closure, it will store if is not in the memory or re-trieve the value if it was calculated before.</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">value</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, arg: <span class="hljs-built_in">u32</span>) -&gt; <span class="hljs-built_in">u32</span> {
        <span class="hljs-keyword">let</span> previously_calculated= <span class="hljs-keyword">self</span>.cache.entry(arg);
        <span class="hljs-keyword">match</span> previously_calculated {
            Entry::Occupied(v) =&gt; *v.get(), <span class="hljs-comment">//retrieve previous value and skip expensive_calculation</span>
            _ =&gt;{
                <span class="hljs-keyword">let</span> value = (<span class="hljs-keyword">self</span>.calculation)(arg);        <span class="hljs-comment">//call expensive_closure</span>
                <span class="hljs-keyword">self</span>.cache.insert(arg, value);              <span class="hljs-comment">//insert new entry</span>
                value }}}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1494">
<h3 id="truecapturing_environment_with_closures">13.4. Capturing environment with closures</h3>
<div class="paragraph data-line-1495">
<p>Closures can capture environment and access variables from the SCOPE WHERE THEY WHERE DEFINED.</p>
</div>
<div class="listingblock data-line-1496">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> x = <span class="hljs-number">4</span>;
<span class="hljs-comment">// even though “x” is not a parameter of equal_to_x closure, the closure is allowed to use x variable because its in</span>
<span class="hljs-comment">//   the same scope.</span>
<span class="hljs-keyword">let</span> equal_to_x = |parameter| {	<span class="hljs-comment">//closure definition</span>
parameter== x
};

<span class="hljs-keyword">let</span> y = <span class="hljs-number">4</span>;

<span class="hljs-built_in">assert!</span>(equal_to_x(y));		<span class="hljs-comment">//closure call, assert passes!.  x is equal to y</span></code></pre>
</div>
</div>
<div class="paragraph data-line-1509">
<p>Closures can capture values from the environment in three ways:</p>
</div>
<div class="ulist data-line-1511">
<ul>
<li class="data-line-1511">
<p>FnOnce, consumes the variables it captures from its enclosing scope, 
known as the closure’s environment. To consume the captured variables, 
the closure must take ownership of these variables and move them into 
the closure when it is defined. The Once part of the name represents the
 fact that the closure can’t take ownership of the same variables more 
than once, so it can be called only once.
You can use <span class="blue">move</span> keyword to take ownership.</p>
</li>
<li class="data-line-1513">
<p>FnMut, can change the environment because it mutably sborrows values.</p>
</li>
<li class="data-line-1514">
<p>Fn, borrows values from the environment immutably.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-1516">
<p>However, when closures capture the environment, it uses memory to 
store the values for the use in the closure body. This use of memory is <span class="red">overhead</span> that we don’t want to pay in more common cases.</p>
</div>
</div>
<div class="sect2 data-line-1518">
<h3 id="trueiterators">13.5. Iterators</h3>
<div class="paragraph data-line-1519">
<p>An iterator is responsible of the logic for traverse over each item and determining when the sequence has finished.</p>
</div>
<div class="sect3 data-line-1521">
<h4 id="truefeatures">13.5.1. Features</h4>
<div class="ulist data-line-1522">
<ul>
<li class="data-line-1522">
<p>Iterators are “lazy”: meaning they have no effect until you call methods that perform an operation.</p>
</li>
<li class="data-line-1523">
<p>Zero-cost abstractions: Iterators apply different kinds <span class="blue">algorithms</span> to different kinds of <span class="blue">sequences</span>, so they <span class="green">normally improve performance.</span></p>
</li>
<li class="data-line-1524">
<p>Interface maintained: algorithms are apply by the compiler, so the <span class="green">user interface is maintained</span> over these different sequences.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-1526">
<h4 id="trueconsumer_adaptors_and_iterator_adaptors">13.5.2. Consumer Adaptors and iterator adaptors</h4>
<div class="paragraph data-line-1527">
<p>All iterators implement Iterator trait. Next method consumes the 
iterated item, this means that once called next() the item will no 
longer be usable because it loses ownership.</p>
</div>
<div class="listingblock data-line-1528">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Iterator</span></span> {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span>;	<span class="hljs-comment">//associated type chapter 19(Advanced features)</span>

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt;; <span class="hljs-comment">//returns either an Item or None</span>

<span class="hljs-comment">// methods with default implementations. This means only next() requires implement-ing.</span>
}
<span class="hljs-keyword">let</span> v1 = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>];
<span class="hljs-comment">//mutable because each call eats/consumes up an item.</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> v1_iter = v1.iter();

<span class="hljs-built_in">assert_eq!</span>(v1_iter.next(), <span class="hljs-literal">Some</span>(&amp;<span class="hljs-number">1</span>));	<span class="hljs-comment">//returns an immutable reference</span>
<span class="hljs-built_in">assert_eq!</span>(v1_iter.next(), <span class="hljs-literal">None</span>);		<span class="hljs-comment">//there is just one element</span>
<span class="hljs-comment">//v1_iter is no longer usable because it was consumed by next(), other methods that use //next() are called “consumer adaptors” because they also consume items via next()</span></code></pre>
</div>
</div>
<div class="paragraph data-line-1545">
<p>similarly into_iter() returns owned values and iter_mut() returns mutable references.
“<strong>Iterator adaptors</strong>” change iterators into another kind of iterator(normally more complex), for example a map. <span class="red">But they need to be called by a consumer adaptor to obtain a result because of iterators lazyness.</span></p>
</div>
<div class="listingblock data-line-1547">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> v1: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt; = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-keyword">let</span> v2: <span class="hljs-built_in">Vec</span>&lt;_&gt; = v1.iter().map(|x| x + <span class="hljs-number">1</span>).collect();

<span class="hljs-built_in">assert_eq!</span>(v2, <span class="hljs-built_in">vec!</span>[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]);</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-1556">
<h4 id="truefiltering_iterators_with_closures">13.5.3. Filtering Iterators with closures</h4>
<div class="paragraph data-line-1557">
<p>The <span class="blue">filter</span> method takes a closure that 
takes each item of the iterator and returns a Boolean, If the closure 
returns true, the value is included in the iterator produced by filter 
otherwhise is excluded.
Example: filtering shoe size: This function retrieves only shoes of a 
specific size.</p>
</div>
<div class="listingblock data-line-1559">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-meta">#[derive(PartialEq, Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Shoe</span></span> {
    size: <span class="hljs-built_in">u32</span>,
    style: <span class="hljs-built_in">String</span>,
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">shoes_in_size</span></span>(shoes: <span class="hljs-built_in">Vec</span>&lt;Shoe&gt;, shoe_size: <span class="hljs-built_in">u32</span>) -&gt; <span class="hljs-built_in">Vec</span>&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect() <span class="hljs-comment">//yellow is the closure.</span>
}</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-1571">
<h4 id="truecreating_our_own_iterators_with_iterator_trait">13.5.4. Creating our own Iterators with Iterator trait</h4>
<div class="paragraph data-line-1572">
<p>As mentioned before, when creating custom iterators, <span class="blue">the only method you are required to provide definition is next()</span>. Ex: Implementing Iterator for a counter struct that counts up to 5, above 5 returns None:</p>
</div>
<div class="listingblock data-line-1573">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Counter</span></span> {
    count: <span class="hljs-built_in">u32</span>,
}

<span class="hljs-keyword">impl</span> Counter {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; Counter {
        Counter { count: <span class="hljs-number">0</span> }
    }
}

<span class="hljs-keyword">impl</span> <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> Counter {
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Item</span></span> = <span class="hljs-built_in">u32</span>;

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">next</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Option</span>&lt;Self::Item&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.count &lt; <span class="hljs-number">5</span> {
            <span class="hljs-keyword">self</span>.count += <span class="hljs-number">1</span>;
            <span class="hljs-literal">Some</span>(<span class="hljs-keyword">self</span>.count)
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-literal">None</span>
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-1598">
<h4 id="truecomparing_performance_loops_vs_iterators">13.5.5. Comparing Performance: Loops vs Iterators</h4>
<div class="paragraph data-line-1599">
<p>Rust developers compared loop vs Iterators on IO Projects and the results are as follows:</p>
</div>
<div class="listingblock data-line-1600">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs">test bench_search_for  ... bench:  <span class="hljs-number">19</span>,<span class="hljs-number">620</span>,<span class="hljs-number">300</span> ns/iter (+/- <span class="hljs-number">915</span>,<span class="hljs-number">700</span>)	<span class="hljs-comment">//loop</span>
test bench_search_iter ... bench:  <span class="hljs-number">19</span>,<span class="hljs-number">234</span>,<span class="hljs-number">900</span> ns/iter (+/- <span class="hljs-number">657</span>,<span class="hljs-number">200</span>)	<span class="hljs-comment">//iterators</span></code></pre>
</div>
</div>
<div class="paragraph data-line-1604">
<p>Iterators are slightly faster. Iterators get compiled to roughly same code as if you’d written the lower-level code yourself. <span class="green">Iterators are one of the Rusts ZERO-COST-ABSTRACTIONS</span>,
 making code look like high level but it gets compiled to optimzed 
instructions. An example of rust optimization is loop unrolling.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1607">
<h2 id="truemore_about_cargo_and_crates_io">14. More about Cargo and Crates.io</h2>
<div class="sectionbody">
<div class="paragraph data-line-1608">
<p>Cargo can do much mora than build, run and test code. You can find everything cargo can do on Cargo book:  <a href="https://doc.rust-lang.org/cargo/index.html" class="bare">https://doc.rust-lang.org/cargo/index.html</a></p>
</div>
<div class="ulist data-line-1610">
<ul>
<li class="data-line-1610">
<p>Customize your build through release profiles</p>
</li>
<li class="data-line-1611">
<p>Publish libraries on crates.io</p>
</li>
<li class="data-line-1612">
<p>Organize large projects with workspaces</p>
</li>
<li class="data-line-1613">
<p>Install binaries from crates.io</p>
</li>
<li class="data-line-1614">
<p>Extend Cargo using custom commands</p>
</li>
</ul>
</div>
<div class="sect2 data-line-1616">
<h3 id="truecustomizing_builds_with_release_profiles">14.1. Customizing builds with release profiles</h3>
<div class="paragraph data-line-1617">
<p>You can add custom profiles on Cargo.toml, by adding [profile.*] sections to any profile you want to cutomize.</p>
</div>
<div class="listingblock data-line-1618">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-comment">//Cargo.toml</span>
[profile.dev]
opt-level = <span class="hljs-number">0</span>
<span class="hljs-comment">//Look on https://doc.rust-lang.org/cargo/reference/profiles.html for the complete list of configuration options.</span>
[profile.release]
opt-level = <span class="hljs-number">3</span>		<span class="hljs-comment">//maximum level of optimization</span></code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1627">
<h3 id="truedocumenting_and_publishing_a_crate_to_crates_io">14.2. Documenting and publishing a Crate to Crates.io</h3>
<div class="paragraph data-line-1628">
<p>Documentation comments use three slashes “///” for documenting 
function and support Markdown notation. Finally you can generate the 
HTML documentation from documentation comments using cargo doc. Also 
“//!” add docomentation to the crate itself.</p>
</div>
<div class="paragraph data-line-1630">
<p>Documentation code, between triple backticks (` ` `) can run with cargo test.</p>
</div>
</div>
<div class="sect2 data-line-1632">
<h3 id="truecargo_workspaces">14.3. Cargo workspaces</h3>
<div class="paragraph data-line-1633">
<p>Help manage multiple related packages that are developed in tandem.</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1635">
<h2 id="truesmart_pointers">15. Smart Pointers</h2>
<div class="sectionbody">
<div class="paragraph data-line-1636">
<p><span class="blue">A pointer</span> is a general concept for a <span class="blue">variable that contains an address in memory</span>.
 This address refers to, or “points at,” some other data. The most 
common kind of pointer in Rust is a reference(&amp;), which only borrows
 data. <span class="green">They don’t have any special capability nor overhead.</span></p>
</div>
<div class="paragraph data-line-1638">
<p><span class="blue">Smart pointers</span>, on the other hand, are <span class="blue">data structures</span> that not only act like a pointer but also:</p>
</div>
<div class="ulist data-line-1640">
<ul>
<li class="data-line-1640">
<p>Have additional capabilities(some smart pointers own data or make some guarantee) and metadata.</p>
</li>
<li class="data-line-1641">
<p>Usually implemented with structs that implement <span class="blue">Deref</span> (reference like behavior) and <span class="blue">Drop</span> (scope) traits.</p>
</li>
<li class="data-line-1642">
<p>Most common smart pointers are:</p>
<div class="ulist data-line-1643">
<ul>
<li class="data-line-1643">
<p><span class="red">Box&lt;T&gt;</span>, for allocating values on the heap</p>
</li>
<li class="data-line-1644">
<p><span class="red">Rc&lt;T&gt;</span>, a reference counting type that 
enables multiple ownership of data by keeping track of the number of 
owners and cleans up when no owner remains.</p>
</li>
<li class="data-line-1645">
<p><span class="red">Ref&lt;T&gt;</span> and RefMut&lt;T&gt;, accessed 
through RefCell&lt;T&gt;, a type that enforces the borrowing rules at 
runtime instead of compile time. Allow us to mutate data of immutable 
references.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph data-line-1647">
<p>We’ve already encountered a few smart pointers, such as String and 
Vec&lt;T&gt; in Chapter 8, Both these types count as smart pointers 
because they own some memory and allow you to manipulate it. They also 
have metadata (such as their capacity) and extra capabilities or 
guarantees (such as with String ensuring its data will always be valid 
UTF-8).</p>
</div>
<div class="sect2 data-line-1649">
<h3 id="trueusing_boxt_to_point_to_data_on_the_heap">15.1. Using Box&lt;T&gt; to Point to Data on the Heap</h3>
<div class="paragraph data-line-1650">
<p>Boxes allow you to store data on the heap. They don’t have 
performance overhead(other than using the heap). They are used in the 
following situations:</p>
</div>
<div class="ulist data-line-1652">
<ul>
<li class="data-line-1652">
<p>Type whose size can’t be known at compile time and you want to use the exact size.</p>
</li>
<li class="data-line-1653">
<p>Large amount of data and you want to transfer ownership but not copy of data.</p>
</li>
<li class="data-line-1654">
<p>You want to own a value and care only that it’s a type that inplements a particular trait.</p>
</li>
</ul>
</div>
<div class="listingblock data-line-1655">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> b = <span class="hljs-built_in">Box</span>::new(<span class="hljs-number">5</span>);			<span class="hljs-comment">//Creates a box pointer that points to value 5 stored on heap.</span>
<span class="hljs-built_in">println!</span>(<span class="hljs-string">"b = {}"</span>, b);		<span class="hljs-comment">//When b goes out of scope, also the data in the heap.</span></code></pre>
</div>
</div>
<div class="paragraph data-line-1659">
<p><strong>Enabling recursive types with boxes</strong></p>
</div>
<div class="paragraph data-line-1661">
<p>At compile time, Rust needs to know how much space a type takes up. 
However, recursive types like the Cons list(constructs a new pair from 2
 arguments) cant be known since the compiler searches for the size of 
each type so when it checks Cons it has ANOTHER CONS which results in 
infinite space allocation.</p>
</div>
<div class="imageblock data-line-1664">
<div class="content">
<img src="index%20Archivos/4_cons.jpg" alt="4 cons">
</div>
<div class="title">Figure 4. cons</div>
</div>
<div class="listingblock data-line-1667">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">List</span></span> {
    Cons(<span class="hljs-built_in">i32</span>, <span class="hljs-built_in">Box</span>&lt;List&gt;),
    Nil,
}
<span class="hljs-keyword">let</span> cons_list = Cons(<span class="hljs-number">1</span>, Cons(<span class="hljs-number">2</span>, Cons(<span class="hljs-number">3</span>, Nil)));</code></pre>
</div>
</div>
<div class="paragraph data-line-1674">
<p>We use Box to store the value indirectly, this means to store the 
pointer to the value instead and because it’s a pointer, size is known 
at compile time.</p>
</div>
<div class="imageblock data-line-1677">
<div class="content">
<img src="index%20Archivos/5_box.jpg" alt="5 box">
</div>
<div class="title">Figure 5. cons + box</div>
</div>
<div class="listingblock data-line-1679">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> cons_list = Cons(<span class="hljs-number">1</span>, <span class="hljs-built_in">Box</span>::new(Cons(<span class="hljs-number">2</span>, <span class="hljs-built_in">Box</span>::new(Cons(<span class="hljs-number">3</span>, <span class="hljs-built_in">Box</span>::new(Nil))))));</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1683">
<h3 id="trueimplementing_dereference_trait">15.2. Implementing Dereference trait</h3>
<div class="paragraph data-line-1684">
<p>Allows us to <span class="blue">customize the behavior of dereference operator</span>. We will create our own smart pointer that performs similar functions to Box&lt;T&gt;(except for the heap storing).</p>
</div>
<div class="listingblock data-line-1685">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> std::ops::Deref;
<span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> MyBox&lt;T&gt; {		<span class="hljs-comment">//We implement Deref trait</span>
    <span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Target</span></span> = T;
<span class="hljs-comment">//deref borrows self and returns a reference to the inner data(field 0(only one) in the //touple)</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">deref</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;Self::Target {
        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>
    }
}
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyBox</span></span>&lt;T&gt;(T);		<span class="hljs-comment">//MyBox type is a tuple with one element of type T</span>

<span class="hljs-keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)			<span class="hljs-comment">//returns a MyBox that hold the value passed.</span>
    }
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch data-line-1705">
<caption class="title">Table 13. Regular refernce vs cutom MyBox</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Regular reference</th>
<th class="tableblock halign-left valign-top">Using custom MyBox&lt;T&gt;</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">let x = 5;<br>
let y = &amp;x;<br>
assert_eq!(5, x);<br>
assert_eq!(5, *y);</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">let x = 5;<br>
let y = MyBox::new(x);<br>
assert_eq!(5, x);<br>
assert_eq!(5, *y);</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-1717">
<p>Types that implement Deref, can implicitly make the dereference 
operation called Deref coercion. For example String into &amp;str is 
posible because String implements Deref.</p>
</div>
</div>
<div class="sect2 data-line-1719">
<h3 id="truedrop_trait">15.3. Drop Trait</h3>
<div class="paragraph data-line-1720">
<p>The drop trait is in the prelude, Rust runs a specified code whenever
 a value goes out of scope, so that you don’t need to explicitly 
deallocate or free memory.</p>
</div>
<div class="listingblock data-line-1721">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CustomSmartPointer</span></span> {
    data: <span class="hljs-built_in">String</span>,
}

<span class="hljs-keyword">impl</span> <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> CustomSmartPointer {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">drop</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Dropping CustomSmartPointer with data `{}`!"</span>, <span class="hljs-keyword">self</span>.data);
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> c = CustomSmartPointer {
        data: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"my stuff"</span>),
    };
    <span class="hljs-keyword">let</span> d = CustomSmartPointer {
        data: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"other stuff"</span>),
    };
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"CustomSmartPointers created."</span>);
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1743">
<h3 id="truerct_the_reference_counted_smart_pointer">15.4. RC&lt;T&gt; the reference counted smart pointer</h3>
<div class="paragraph data-line-1744">
<p>When we want a single value to have multiple owners, Rust has a type 
called Rc&lt;T&gt; which is an abbreviation for reference counting. For 
example in a graph, where multiple edges point to the same node, that 
node is conceptually owned by all edges.  We can use Rc&lt;T&gt; for:</p>
</div>
<div class="ulist data-line-1746">
<ul>
<li class="data-line-1746">
<p>Share data via immutable references(for reading only). If you want to mutate data, you can see RefCell&lt;T&gt;(next section).</p>
</li>
<li class="data-line-1747">
<p>Cleanup data only when pointer has 0 owners</p>
</li>
</ul>
</div>
<div class="paragraph data-line-1749">
<p>Imagine you want to point a as follows:</p>
</div>
<div class="imageblock data-line-1751">
<div class="content">
<img src="index%20Archivos/6_rc.jpg" alt="6 rc">
</div>
</div>
<div class="paragraph data-line-1753">
<p>Since Cons variants <mark>owns</mark> the data, sharing “a” with “b” 
would result in a compiler error. Instead, when we create b, we can 
clone the Rc&lt;List&gt; that “a” is holding(thereby increasing the 
number of reference of the Rc).</p>
</div>
<div class="listingblock data-line-1754">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">List</span></span> {
    Cons(<span class="hljs-built_in">i32</span>, Rc&lt;List&gt;),
    Nil,
}

<span class="hljs-keyword">use</span> crate::List::{Cons, Nil};
<span class="hljs-keyword">use</span> std::rc::Rc;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> a = Rc::new(Cons(<span class="hljs-number">5</span>, Rc::new(Cons(<span class="hljs-number">10</span>, Rc::new(Nil)))));
    <span class="hljs-keyword">let</span> b = Cons(<span class="hljs-number">3</span>, Rc::clone(&amp;a));				<span class="hljs-comment">// increases the counter of owners</span>
    <span class="hljs-keyword">let</span> c = Cons(<span class="hljs-number">4</span>, Rc::clone(&amp;a));</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1769">
<h3 id="truerefcellt_interior_mutability_pattern">15.5. RefCell&lt;T&gt; interior mutability pattern</h3>
<div class="paragraph data-line-1770">
<p>Interior mutability is a design pattern in Rust that allows you to <span class="underline">mutate data even when there are immutable references to that data</span>.
 To mutate data, the pattern uses unsafe code inside a data structure, 
to bend Rusts usual rules that govern mutation and borrowing.</p>
</div>
<div class="paragraph data-line-1772">
<p>With ReffCell&lt;T&gt; borrowing rules are enforced at <strong>runtime(panics and exits like C)</strong>.
 The advantage of this is that certain memory-safe scenarios are 
allowed(which normally are disallowed by compile-time checks). For 
example, allow a value to mutate itself in its methods but appear 
immutable to other code.</p>
</div>
<div class="paragraph data-line-1774">
<p>Rc&lt;T&gt; and RefCell&lt;T&gt; are <span class="red">only for use in single-threaded scenarios.</span></p>
</div>
<div class="paragraph data-line-1776">
<p><strong>Mock Objects: a use case for interior mutability</strong></p>
</div>
<div class="paragraph data-line-1778">
<p>In this example we create a library that tracks a value against a 
maximum value and sends messages based on how close to the maximum value
 the current value is. This could be used to keep track of user quota.</p>
</div>
<div class="paragraph data-line-1780">
<p>A test double is the general programming concept for a type used in 
place of another type during testing. Mock objects are specific types of
 test doubles that record what happens during a test so you can assert 
that the correct actions took place.</p>
</div>
<div class="paragraph data-line-1782">
<p>Rust doesn’t have objects in the same sense as other languages have 
objects, and Rust doesn’t have mock object functionality built into the 
standard library as some other languages do. However, you can definitely
 create a struct that will serve the same purposes as a mock object.</p>
</div>
<div class="listingblock data-line-1783">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Messenger</span></span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send</span></span>(&amp;<span class="hljs-keyword">self</span>, msg: &amp;<span class="hljs-built_in">str</span>);
}

<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LimitTracker</span></span>&lt;<span class="hljs-symbol">'a</span>, T: Messenger&gt; {
    messenger: &amp;<span class="hljs-symbol">'a</span> T,
    value: <span class="hljs-built_in">usize</span>,
    max: <span class="hljs-built_in">usize</span>,
}

<span class="hljs-keyword">impl</span>&lt;<span class="hljs-symbol">'a</span>, T&gt; LimitTracker&lt;<span class="hljs-symbol">'a</span>, T&gt;
<span class="hljs-keyword">where</span>
    T: Messenger,
{
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(messenger: &amp;T, max: <span class="hljs-built_in">usize</span>) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: <span class="hljs-number">0</span>,
            max,
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_value</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, value: <span class="hljs-built_in">usize</span>) {
        <span class="hljs-keyword">self</span>.value = value;

        <span class="hljs-keyword">let</span> percentage_of_max = <span class="hljs-keyword">self</span>.value <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span> / <span class="hljs-keyword">self</span>.max <span class="hljs-keyword">as</span> <span class="hljs-built_in">f64</span>;

        <span class="hljs-keyword">if</span> percentage_of_max &gt;= <span class="hljs-number">1.0</span> {
            <span class="hljs-keyword">self</span>.messenger.send(<span class="hljs-string">"Error: You are over your quota!"</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> percentage_of_max &gt;= <span class="hljs-number">0.9</span> {
            <span class="hljs-keyword">self</span>.messenger
                .send(<span class="hljs-string">"Urgent warning: You've used up over 90% of your quota!"</span>);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> percentage_of_max &gt;= <span class="hljs-number">0.75</span> {
            <span class="hljs-keyword">self</span>.messenger
                .send(<span class="hljs-string">"Warning: You've used up over 75% of your quota!"</span>);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1824">
<p><span class="blue">Messanger</span> trait has a method called <span class="blue">send</span>, which takes an <span class="red">immutable</span>
 reference to self and the text message. This trait is the interface our
 mock objects needs to implement, so our Mock object will look as 
follows:</p>
</div>
<div class="listingblock data-line-1825">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-meta">#[cfg(test)]</span>
<span class="hljs-keyword">mod</span> tests {
    <span class="hljs-keyword">use</span> super::*;
    <span class="hljs-keyword">use</span> std::cell::RefCell;

    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MockMessenger</span></span> {
        sent_messages: RefCell&lt;<span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt;&gt;, 	<span class="hljs-comment">//sent messages is a RefCell to use interior mutability</span>
    }

    <span class="hljs-keyword">impl</span> MockMessenger {
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(<span class="hljs-built_in">vec!</span>[]),
            }
        }
    }

    <span class="hljs-keyword">impl</span> Messenger <span class="hljs-keyword">for</span> MockMessenger {
        <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">send</span></span>(&amp;<span class="hljs-keyword">self</span>, message: &amp;<span class="hljs-built_in">str</span>) {
            <span class="hljs-keyword">self</span>.sent_messages.borrow_mut().push(<span class="hljs-built_in">String</span>::from(message));
        }
    }

    <span class="hljs-meta">#[test]</span>
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">it_sends_an_over_75_percent_warning_message</span></span>() {
        <span class="hljs-comment">// --snip--</span>

        <span class="hljs-built_in">assert_eq!</span>(mock_messenger.sent_messages.borrow().len(), <span class="hljs-number">1</span>);
    }
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1857">
<p>Rc and RefCell can be combined to create multiple owners of mutable data. However, this can create memory leaks.</p>
</div>
</div>
<div class="sect2 data-line-1859">
<h3 id="truememory_leaks">15.6. Memory leaks</h3>
<div class="paragraph data-line-1860">
<p>Rust doesn’t not guarantee memory safety, althought its difficult. 
Memory leaks due to reference of items that refer to each other in a 
cycle are possible because the reference count will never reach 0.</p>
</div>
<div class="paragraph data-line-1862">
<p>To prevent this Rust uses Rc::downgrade which retrieves a 
Weak&lt;T&gt; smart pointer that basically says that we don’t own the 
item. Instead of strong_count weak_count is increased but item is not 
cleanup when reaches 0.</p>
</div>
<div class="listingblock data-line-1863">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs">Creating a Tree Data structure
<span class="hljs-keyword">use</span> std::cell::RefCell;
<span class="hljs-keyword">use</span> std::rc::Rc;

<span class="hljs-meta">#[derive(Debug)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span> {
    value: <span class="hljs-built_in">i32</span>,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;, 		<span class="hljs-comment">//a child doesn’t own a parent so we use weak RefCell.</span>
    children: RefCell&lt;<span class="hljs-built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,	<span class="hljs-comment">//a Node own(and drops) its children and share ownership(Rc).</span>
					<span class="hljs-comment">//also we want to modify children(RefCell)</span>
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1877">
<p>Leaf and branch operations are as follows:</p>
</div>
<div class="listingblock data-line-1879">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs">    <span class="hljs-keyword">let</span> leaf = Rc::new(Node {
        value: <span class="hljs-number">3</span>,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(<span class="hljs-built_in">vec!</span>[]),
    });

    <span class="hljs-keyword">let</span> branch = Rc::new(Node {
        value: <span class="hljs-number">5</span>,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(<span class="hljs-built_in">vec!</span>[Rc::clone(&amp;leaf)]),	<span class="hljs-comment">//we can get from branch to leaf through branch.children</span>
    });
*leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);	<span class="hljs-comment">//update the parent of leaf node</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1894">
<h2 id="truefearless_concurrencyand_or_parallel">16. Fearless Concurrency(and or parallel)</h2>
<div class="sectionbody">
<div class="paragraph data-line-1895">
<p>Concurrent programming, where different parts of a program execute independently, and</p>
</div>
<div class="paragraph data-line-1897">
<p>Parallel programming, where different parts of a program execute at the same time are becoming important.</p>
</div>
<div class="paragraph data-line-1899">
<p>Ownership and type systems are a powerful set of tools to manage memory safety and concurrency problems.</p>
</div>
<div class="paragraph data-line-1901">
<p>Here are the topics we’ll cover in this chapter:</p>
</div>
<div class="ulist data-line-1903">
<ul>
<li class="data-line-1903">
<p>How to create threads to run multiple pieces of code at the same time</p>
</li>
<li class="data-line-1904">
<p>Message-passing concurrency, where channels send messages between threads</p>
</li>
<li class="data-line-1905">
<p>Shared-state concurrency, where multiple threads have access to some piece of data</p>
</li>
<li class="data-line-1906">
<p>The Sync and Send traits, which extend Rust’s concurrency guarantees 
to user-defined types as well as types provided by the standard library</p>
</li>
</ul>
</div>
<div class="sect2 data-line-1908">
<h3 id="trueusing_threads_to_run_code_simultaneously">16.1. Using threads to run code simultaneously</h3>
<div class="paragraph data-line-1909">
<p>In most current OS, a program code run in a process and the OS 
manages multiple processes at once. Within your program you can also 
have independent parts that run simultaneously(threads→program flow). 
However, since threads run simultaneously, they can led to problems such
 as:</p>
</div>
<div class="ulist data-line-1911">
<ul>
<li class="data-line-1911">
<p>Race conditions, where threads are accessing data or resources in an inconsistent order</p>
</li>
<li class="data-line-1912">
<p>Deadlocks, where two threads are waiting for each other to finish 
using a resource the other thread has, preventing both threads from 
continuing</p>
</li>
<li class="data-line-1913">
<p>Bugs, that happen only in certain situations and are hard to reproduce and fix reliably</p>
</li>
</ul>
</div>
<div class="paragraph data-line-1915">
<p>Programming in a multithreaded context requires careful thought and 
different code structure than the one for single thread.  Programming 
languages implement threads in few different ways:</p>
</div>
<div class="paragraph data-line-1917">
<p>Some languages provide an API for dealing with threads. This model is
 called 1:1, because one OS thread calls one language thread. This is 
the Rust standard library implementation.</p>
</div>
<div class="paragraph data-line-1919">
<p>Some provide their own special implementation of threads. This is 
called M:N model, because this can run M threads per N OS. This can be 
achieved through crates(with the corresponding runtime overhead).
Spawn:</p>
</div>
<div class="paragraph data-line-1922">
<p><strong>Creating a new thread</strong></p>
</div>
<div class="listingblock data-line-1924">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs">thread::spawn( | | {
        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> {
            <span class="hljs-built_in">println!</span>(<span class="hljs-string">"hi number {} from the spawned thread!"</span>, i);
            thread::sleep(Duration::from_millis(<span class="hljs-number">1</span>));
        }
<span class="hljs-comment">//spawn thread will die once main thread finishes, so it will be able to print only 5 values.</span>
   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"hi number {} from the main thread!"</span>, i);
        thread::sleep(Duration::from_millis(<span class="hljs-number">1</span>));
    }
    });</code></pre>
</div>
</div>
<div class="paragraph data-line-1940">
<p><strong>Join: waiting for all threads to finish</strong></p>
</div>
<div class="paragraph data-line-1942">
<p>Previous code stops prematurely and also doesn’t guarantee that the 
spawned thread will get to run at all. We can store the return value of 
thread::spawn which is a joinhandle, an owned value that when we call 
join method, will wait for its thread to finish.</p>
</div>
<div class="listingblock data-line-1943">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> handle = thread::spawn(|| {
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"hi number {} from the spawned thread!"</span>, i);
        thread::sleep(Duration::from_millis(<span class="hljs-number">1</span>));
    }
});
<span class="hljs-comment">// handle.join().unwrap();		//if we move the join handle, it will run everything on the spawn thread first</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">5</span> {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"hi number {} from the main thread!"</span>, i);
    thread::sleep(Duration::from_millis(<span class="hljs-number">1</span>));
}

handle.join().unwrap();		<span class="hljs-comment">//waits for spawned thread to finish, alternating OS processing power.</span></code></pre>
</div>
</div>
<div class="paragraph data-line-1958">
<p><strong>Using data on multiple threads</strong></p>
</div>
<div class="paragraph data-line-1960">
<p>The <span class="blue">move</span> closure is often used alongside 
thread::spawn to use data from one thread into another. Move keyword 
force the closure to take ownership of the values.</p>
</div>
<div class="listingblock data-line-1961">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> v = <span class="hljs-built_in">vec!</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> handle = thread::spawn(<span class="hljs-keyword">move</span> | | {
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Here's a vector: {:?}"</span>, v);
});

handle.join().unwrap();</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1970">
<h3 id="trueusing_message_passing_to_transfer_data_between_threads">16.2. Using message passing to transfer data between threads</h3>
<div class="paragraph data-line-1971">
<p>A popular approach to ensuring safe concurrency is through message 
passing, where threads communicate by sending each other messages 
containing data. Rust accomplish message-sending with channel, a 
component that has transmitter and receiver.</p>
</div>
<div class="paragraph data-line-1973">
<p>First we can create a new channel using mpsc::channel (mpsc stands 
for multiple producer, single consumer). This means a channel can have 
multiple sending ends but only one receiving. Channel returns a tuple 
for transmitting and receiving end. To create multiple 
producers/transmitter, you can clone the tx end.</p>
</div>
<div class="paragraph data-line-1975">
<p>Then we can use <span class="blue">move</span> to take <span class="blue">tx</span> into the closure so the spawned thread owns tx, and transmitting thread uses <span class="blue">send()</span> method which returns a Result&lt;T, E&gt;(we use unwrap instead, for simplicity).</p>
</div>
<div class="paragraph data-line-1977">
<p>Finally Receiving end uses <span class="blue">recv()</span> which also returns a result so in case sending end closes, recv return an error.</p>
</div>
<div class="listingblock data-line-1978">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> std::sync::mpsc;
<span class="hljs-keyword">use</span> std::thread;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> (tx, rx) = mpsc::channel();

    thread::spawn(<span class="hljs-keyword">move</span> || {
        <span class="hljs-keyword">let</span> val = <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"hi"</span>);
        tx.send(val).unwrap();
    });

    <span class="hljs-keyword">let</span> received = rx.recv().unwrap();
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Got: {}"</span>, received);
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1995">
<h3 id="trueshared_state_concurrency">16.3. Shared-state Concurrency</h3>
<div class="paragraph data-line-1996">
<p>Message passing is a good way to handle concurrency/parallelism but we can also manage it with <span class="green">shared-memory</span>.
 Channels are similar to single ownership because once you transfer the 
value down a channel, you should no longer use it. Shared memory is like
 multiple ownership so we need mutexes to control access.</p>
</div>
<div class="paragraph data-line-1998">
<p><strong>Using mutexes to allow data from one thread at a time</strong></p>
</div>
<div class="paragraph data-line-2000">
<p>To access data in a mutex, a thread must first signal that it wants 
to aquire the mutex’s lock(data structure that controls access). You 
have to remember 2 rules when managing mutexes:</p>
</div>
<div class="ulist data-line-2002">
<ul>
<li class="data-line-2002">
<p>You must attempt to acquire the lock before using the data.</p>
</li>
<li class="data-line-2003">
<p>When you’re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.
Mutex&lt;T&gt; API</p>
</li>
</ul>
</div>
<div class="listingblock data-line-2005">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> std::sync::Mutex;
<span class="hljs-keyword">let</span> m = Mutex::new(<span class="hljs-number">5</span>);		<span class="hljs-comment">//smart pointer called MutexGuard.</span>

{
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> num = m.lock().unwrap();		<span class="hljs-comment">//will fail if another thread is holding the llock</span>
    *num = <span class="hljs-number">6</span>;
}</code></pre>
</div>
</div>
<div class="paragraph data-line-2015">
<p><strong>Sharing a Mutex between multiple threads</strong></p>
</div>
<div class="paragraph data-line-2017">
<p>As we recall <span class="red">Rc should not be used on multithreaded systems</span>,
 Fortunately Arc is a type like Rc that is safe to use in concurrent 
situations. "A" stands for atomic. We normally do not use Arc because it
 comes with a performance penalty.</p>
</div>
<div class="listingblock data-line-2019">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-comment">//let counter = Mutex::new(0);  //this yields an error due to owning</span>
<span class="hljs-comment">//let counter = Rc::new(Mutex::new(0));  //Rc doesn’t work on multiple threads</span>
<span class="hljs-keyword">let</span> counter = Arc::new(Mutex::new(<span class="hljs-number">0</span>));   <span class="hljs-comment">// Arc is a type like Rc that is safe in concurrent situations.</span>
<span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> handles = <span class="hljs-built_in">vec!</span>[];

<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>..<span class="hljs-number">10</span> {
   <span class="hljs-keyword">let</span> counter = Arc::clone(&amp;counter)
    <span class="hljs-keyword">let</span> handle = thread::spawn(<span class="hljs-keyword">move</span> || {
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> num = counter.lock().unwrap();

        *num += <span class="hljs-number">1</span>;
    });
    handles.push(handle);
}

<span class="hljs-keyword">for</span> handle <span class="hljs-keyword">in</span> handles {
    handle.join().unwrap();
}

<span class="hljs-built_in">println!</span>(<span class="hljs-string">"Result: {}"</span>, *counter.lock().unwrap());</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-2045">
<h3 id="trueembedded_concurrency_with_sync_and_send_traits">16.4. Embedded concurrency with Sync and Send traits</h3>
<div class="paragraph data-line-2046">
<p><span class="blue">Send</span> marker trait indicates that <strong>ownership</strong> of values of the type implementing Send can be <strong>transferred between threads</strong>.</p>
</div>
<div class="paragraph data-line-2048">
<p><span class="blue">Sync</span> marker trait indicates that it is safe for the type implementing Sync to be <strong>referenced from multiple threads</strong></p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-2051">
<h2 id="trueobject_oriented_programming">17. Object Oriented Programming</h2>
<div class="sectionbody">
<div class="paragraph data-line-2052">
<p>Rust implements some features of OOP languages like:</p>
</div>
<div class="ulist data-line-2054">
<ul>
<li class="data-line-2054">
<p>Encapsulation: hiding implementation details to external code → pub keyword</p>
</li>
<li class="data-line-2055">
<p>Objects: A package of data and procedures → structs and enums have data, and impl blocks provide methods on structs and enums.</p>
</li>
<li class="data-line-2056">
<p><span class="red">Inheritance</span>: inherit data and behavior from another object definition. → There is <span class="red">no way for Rust</span>
 to define a struct that inherits parent struct field and methods. 
However, Rust provides means to reuse implementations with generics or 
to use default implementations with traits.</p>
</li>
<li class="data-line-2057">
<p><span class="red">Polymorphism</span>: enable a child to be used in 
the same places as a parent type, this means, substitute multiple 
objects for each other at runtime if they share certain characteristics.
  Rust instead <span class="green">uses generics to abstract over different possible types and trait bounds to impose constraints</span> on what those types must provide. This is sometimes called bounded parametric polymorphism.</p>
</li>
</ul>
</div>
<div class="sect2 data-line-2059">
<h3 id="trueusing_trait_objects_allow_values_of_different_types">17.1. Using trait objects: Allow values of different types</h3>
<div class="paragraph data-line-2060">
<p>In <a href="#truecommon_collections">Common collections</a>, we 
mentioned that vectors can only store elements of one type. We used 
SpreadsheetCell to hold integers, floats and text. This is perfect for 
items with fixed set of types.</p>
</div>
<div class="paragraph data-line-2062">
<p>However, we sometimes we want our user to be able to extend the set 
of types that are valid. For example on a GUI, you want to implement 
draw method on each component that we want to print on screen.</p>
</div>
<div class="paragraph data-line-2064">
<p><strong>Defining a trait for common behavior</strong></p>
</div>
<div class="paragraph data-line-2066">
<p>To provide drawable components, we can define a trait named Draw that
 will have one method named draw. Then, we define a vector that takes a 
trait object(a trait object point to an instance of a type and a table 
used to look up trait methods at runtime).</p>
</div>
<div class="listingblock data-line-2068">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Draw</span></span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">draw</span></span>(&amp;<span class="hljs-keyword">self</span>);
}

<span class="hljs-comment">//We create a trait object by specifying some sort of pointer, such as a &amp; reference or a Box&lt;T&gt; smart pointer, then the dyn keyword, and then specifying the relevant trait.</span>
<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Screen</span></span> {
    <span class="hljs-keyword">pub</span> components: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">Box</span>&lt;dyn Draw&gt;&gt;,
}
<span class="hljs-keyword">impl</span> Screen {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">run</span></span>(&amp;<span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">for</span> component <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.components.iter() {
            component.draw();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph data-line-2087">
<p>A generic type parameter &lt;T&gt; <span class="red">can only be substituted with one concrete type at a time</span>, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime.</p>
</div>
<div class="paragraph data-line-2089">
<p><strong>Implementing a trait</strong></p>
</div>
<div class="paragraph data-line-2091">
<p>Then someone can use our GUI library to implement a selection box.</p>
</div>
<div class="listingblock data-line-2092">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">use</span> gui::Draw;
<span class="hljs-keyword">use</span> gui::{Button, Screen};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SelectBox</span></span> {
    width: <span class="hljs-built_in">u32</span>,
    height: <span class="hljs-built_in">u32</span>,
    options: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">String</span>&gt;,
}

<span class="hljs-keyword">impl</span> Draw <span class="hljs-keyword">for</span> SelectBox {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">draw</span></span>(&amp;<span class="hljs-keyword">self</span>) {
        <span class="hljs-comment">// code to actually draw a select box</span>
    }
}


<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> screen = Screen {
        components: <span class="hljs-built_in">vec!</span>[
            <span class="hljs-built_in">Box</span>::new(SelectBox {
                width: <span class="hljs-number">75</span>,
                height: <span class="hljs-number">10</span>,
                options: <span class="hljs-built_in">vec!</span>[
                    <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Yes"</span>),
                    <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"Maybe"</span>),
                    <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"No"</span>),
                ],
            }),
            <span class="hljs-built_in">Box</span>::new(Button {
                width: <span class="hljs-number">50</span>,
                height: <span class="hljs-number">10</span>,
                label: <span class="hljs-built_in">String</span>::from(<span class="hljs-string">"OK"</span>),
            }),
        ],
    };

    screen.run();
}</code></pre>
</div>
</div>
<div class="admonitionblock warning data-line-2133">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph data-line-2134">
<p>Safety is required for trait objects</p>
</div>
<div class="paragraph data-line-2136">
<p>You can only make object-safe traits into trait objects. Rust forgets
 the concrete type implementing a trait once you’ve used a trait 
objects, which basically means that:</p>
</div>
<div class="ulist data-line-2138">
<ul>
<li class="data-line-2138">
<p>The return type must not be Self.</p>
</li>
<li class="data-line-2139">
<p>There should be no generic type parameters.</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2 data-line-2142">
<h3 id="trueimplementing_object_oriented_design_pattern">17.2. Implementing Object-Oriented design pattern</h3>
<div class="paragraph data-line-2143">
<p>We will implement a blog post workflow that has the following functionalities:</p>
</div>
<div class="ulist data-line-2145">
<ul>
<li class="data-line-2145">
<p>A blog post starts as an empty draft.</p>
</li>
<li class="data-line-2146">
<p>When the draft is done, a review of the post is requested.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-2148">
<p>Using state pattern design: a value has some internal state which is 
represented by a set of state objects and values behavior changes based 
on the internal state. so we dont need to change code value but behavior
 of state objects.</p>
</div>
<div class="paragraph data-line-2150">
<p><strong>Defining post and creating new instance in draft state</strong></p>
</div>
<div class="paragraph data-line-2152">
<p>When we create a new Post, we set its state field to a Some value 
that holds a Box. This Box points to a new instance of the Draft struct.
 This ensures whenever we create a new instance of Post, it will start 
out as a draft</p>
</div>
<div class="listingblock data-line-2154">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Post</span></span> {
    state: <span class="hljs-built_in">Option</span>&lt;<span class="hljs-built_in">Box</span>&lt;dyn State&gt;&gt;,
    content: <span class="hljs-built_in">String</span>,
}

<span class="hljs-keyword">impl</span> Post {
    <span class="hljs-comment">// --snip--</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; Post {
        Post {
            state: <span class="hljs-literal">Some</span>(<span class="hljs-built_in">Box</span>::new(Draft {})),
            content: <span class="hljs-built_in">String</span>::new(),
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">add_text</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, text: &amp;<span class="hljs-built_in">str</span>) {
        <span class="hljs-keyword">self</span>.content.push_str(text);
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">content</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; &amp;<span class="hljs-built_in">str</span> {
        <span class="hljs-keyword">self</span>.state.as_ref().unwrap().content(<span class="hljs-keyword">self</span>)
    }
<span class="hljs-comment">// ability to change state from draft to Pending review</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">request_review</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(s) = <span class="hljs-keyword">self</span>.state.take() {
            <span class="hljs-keyword">self</span>.state = <span class="hljs-literal">Some</span>(s.request_review()) <span class="hljs-comment">// Calls internal request_review</span>
        }
    }
}

<span class="hljs-comment">// shared behavior by different post states</span>
<span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">State</span></span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">request_review</span></span>(<span class="hljs-keyword">self</span>: <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) -&gt; <span class="hljs-built_in">Box</span>&lt;dyn State&gt;;
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">content</span></span>&lt;<span class="hljs-symbol">'a</span>&gt;(&amp;<span class="hljs-keyword">self</span>, post: &amp;<span class="hljs-symbol">'a</span> Post) -&gt; &amp;<span class="hljs-symbol">'a</span> <span class="hljs-built_in">str</span> {
        <span class="hljs-string">""</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Draft</span></span> {}

<span class="hljs-comment">// internal request review for Draft</span>
<span class="hljs-keyword">impl</span> State <span class="hljs-keyword">for</span> Draft {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">request_review</span></span>(<span class="hljs-keyword">self</span>: <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) -&gt; <span class="hljs-built_in">Box</span>&lt;dyn State&gt; {
        <span class="hljs-built_in">Box</span>::new(PendingReview {})
    }
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PendingReview</span></span> {}

<span class="hljs-comment">// internal request review for Pending review</span>
<span class="hljs-keyword">impl</span> State <span class="hljs-keyword">for</span> PendingReview {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">request_review</span></span>(<span class="hljs-keyword">self</span>: <span class="hljs-built_in">Box</span>&lt;<span class="hljs-keyword">Self</span>&gt;) -&gt; <span class="hljs-built_in">Box</span>&lt;dyn State&gt; {
        <span class="hljs-keyword">self</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph data-line-2211">
<p><strong>Trade-off of state pattern</strong></p>
</div>
<div class="paragraph data-line-2213">
<p>The methods on Post know nothing about the various behaviors. The way
 we organized the code, we have to look in only one place to know the 
different ways a published post can behave: the implementation of the 
State trait on the Published struct.</p>
</div>
<div class="paragraph data-line-2215">
<p>The downsides of state pattern is that two adjacent states are coupled to each other. Also some duplicated logic exists.</p>
</div>
<div class="paragraph data-line-2217">
<p>If we were to create an alternative implementation that didn’t use 
the state pattern, we might instead use match expressions in the methods
 on Post or implementing transitions as different types(Post can be 
published but DraftPost cannot).</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-2219">
<h2 id="truepatterns_and_matching">18. Patterns and Matching</h2>
<div class="sectionbody">
<div class="paragraph data-line-2220">
<p>Patterns give you more control over the porgrams flow, a pattern consist of:</p>
</div>
<div class="ulist data-line-2222">
<ul>
<li class="data-line-2222">
<p>Literals</p>
</li>
<li class="data-line-2223">
<p>Destructured arrays, enums, structs, or tuples</p>
</li>
<li class="data-line-2224">
<p>Variables</p>
</li>
<li class="data-line-2225">
<p>Wildcards</p>
</li>
<li class="data-line-2226">
<p>Placeholders</p>
</li>
</ul>
</div>
<div class="paragraph data-line-2228">
<p>To use a pattern, we compare it to some value. If the pattern matches the value, we use the value parts in our code.</p>
</div>
<div class="sect2 data-line-2230">
<h3 id="truepatterns_use_cases">18.1. Patterns use cases</h3>
<div class="paragraph data-line-2232">
<p><strong>Match arms</strong></p>
</div>
<div class="paragraph data-line-2234">
<p>All posibilities must be handled.</p>
</div>
<div class="listingblock data-line-2235">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">match</span> VALUE {
    PATTERN1 | PATTERN2  =&gt; EXPRESSION,     <span class="hljs-comment">//multiple patterns</span>
    PATTERN <span class="hljs-keyword">if</span> condition &lt; <span class="hljs-number">5</span> =&gt; EXPRESSION, <span class="hljs-comment">//extra conditions</span>
    range0..=range_last =&gt; EXPRESSION,      <span class="hljs-comment">//range</span>
    _ =&gt; Expression <span class="hljs-comment">//handles any other case</span>
}</code></pre>
</div>
</div>
<div class="paragraph data-line-2244">
<p><strong>Conditional if let</strong></p>
</div>
<div class="paragraph data-line-2246">
<p>Shorter way of matching only one case. However is not exhaustive(possible logic bugs).</p>
</div>
<div class="listingblock data-line-2248">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">let</span> favorite_color: <span class="hljs-built_in">Option</span>&lt;&amp;<span class="hljs-built_in">str</span>&gt; = <span class="hljs-literal">None</span>;
    <span class="hljs-keyword">let</span> is_tuesday = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">let</span> age: <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">u8</span>, _&gt; = <span class="hljs-string">"34"</span>.parse();

    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(color) = favorite_color {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Using your favorite color, {}, as the background"</span>, color);
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> is_tuesday {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Tuesday is green day!"</span>);</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-2259">
<h3 id="truerefutability_wether_a_pattern_might_fail_or_match">18.2. Refutability: wether a pattern might Fail or match</h3>
<div class="paragraph data-line-2260">
<p>Patterns come in two forms: refutable and irrefutable. Patterns that 
will match for any possible value passed are irrefutable(let x = 5) and 
patterns that can fail are refutable as Some(x).</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-2262">
<h2 id="trueadvanced_features">19. Advanced features</h2>
<div class="sectionbody">
<div class="paragraph data-line-2263">
<p>Here are some of the most advanced features in Rusts that are useful in very specific situations:</p>
</div>
<div class="ulist data-line-2265">
<ul>
<li class="data-line-2265">
<p>Unsafe Rust: how to opt out of some of Rust’s guarantees and take responsibility for manually upholding those guarantees</p>
</li>
<li class="data-line-2266">
<p>Advanced traits: associated types, default type parameters, fully 
qualified syntax, supertraits, and the newtype pattern in relation to 
traits</p>
</li>
<li class="data-line-2267">
<p>Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types</p>
</li>
<li class="data-line-2268">
<p>Advanced functions and closures: function pointers and returning closures
Macros: ways to define code that defines more code at compile time</p>
</li>
</ul>
</div>
<div class="sect2 data-line-2271">
<h3 id="trueunsafe_rust">19.1. Unsafe Rust</h3>
<div class="paragraph data-line-2272">
<p>Unsafe Rust exists because, by nature, static analysis is 
conservative. Although the code might be okay, if the Rust compiler 
doesn’t have enough information to be confident, it will reject the 
code. In these cases, you can use unsafe code to tell the compiler, <span class="green"><strong>“Trust me, I know what I’m doing.”</strong></span> (The downside is that you use it at your own risk).</p>
</div>
<div class="paragraph data-line-2274">
<p>Another reason Rust has an unsafe alter ego is that the <strong>underlying computer hardware is inherently unsafe</strong>.
 If Rust didn’t let you do unsafe operations, you couldn’t do certain 
tasks. Rust needs to allow you to do low-level systems programming, such
 as directly interacting with the operating system or even writing your 
own operating system.</p>
</div>
<div class="paragraph data-line-2276">
<p><strong>Unsafe superpower</strong></p>
</div>
<div class="paragraph data-line-2278">
<p>To switch to unsafe Rust, use the <span class="blue">unsafe</span> 
keyword and then start a new block that holds the unsafe code. You can 
take five actions in unsafe Rust, called unsafe superpowers:</p>
</div>
<div class="ulist data-line-2280">
<ul>
<li class="data-line-2280">
<p>Dereference a raw pointer</p>
</li>
<li class="data-line-2281">
<p>Call an unsafe function or method</p>
</li>
<li class="data-line-2282">
<p>Access or modify a mutable static variable</p>
</li>
<li class="data-line-2283">
<p>Implement an unsafe trait</p>
</li>
<li class="data-line-2284">
<p>Access fields of unions</p>
</li>
</ul>
</div>
<div class="paragraph data-line-2286">
<p>Unsafe doesn’t turn off the borrow checker or disable any other 
safety check apart from these 5 actions. In addition, unsafe does not 
mean the code inside the block is necessarily dangerous or that it will 
definitely have memory safety problems: the intent is that as the 
programmer, you’ll ensure the code inside an unsafe block will access 
memory in a valid way. However, mistakes can still happen but they will 
be within unsafe blocks.</p>
</div>
<div class="paragraph data-line-2288">
<p><strong>Dereferencing a raw pointer</strong></p>
</div>
<div class="paragraph data-line-2290">
<p>Unsafe Rust has two new types called raw pointers that are similar to
 references. As with references, raw pointers can be immutable or 
mutable and are written as *const T and *mut T, respectively. raw 
ponters:</p>
</div>
<div class="ulist data-line-2292">
<ul>
<li class="data-line-2292">
<p>Are allowed to ignore the borrowing rules by having both immutable 
and mutable pointers or multiple mutable pointers to the same location</p>
</li>
<li class="data-line-2293">
<p>Aren’t guaranteed to point to valid memory</p>
</li>
<li class="data-line-2294">
<p>Are allowed to be null</p>
</li>
<li class="data-line-2295">
<p>Don’t implement any automatic cleanup</p>
</li>
</ul>
</div>
<div class="listingblock data-line-2297">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> address = <span class="hljs-number">0x012345usize</span>;  <span class="hljs-comment">//raw ,memory location(NOT RECOMMENDED)</span>
<span class="hljs-comment">// we can create raw pointers in safe code but we cant dereference outside unsafe.</span>
    <span class="hljs-keyword">let</span> r1 = &amp;num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">i32</span>;        <span class="hljs-comment">//immutable raw pointer</span>
    <span class="hljs-keyword">let</span> r2 = &amp;<span class="hljs-keyword">mut</span> num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">i32</span>;      <span class="hljs-comment">//mutable raw pointer</span>
}</code></pre>
</div>
</div>
<div class="paragraph data-line-2307">
<p><strong>Calling unsafe functions  or methods</strong></p>
</div>
<div class="listingblock data-line-2309">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">dangerous</span></span>() {}

<span class="hljs-keyword">unsafe</span> {
    dangerous();
}</code></pre>
</div>
</div>
<div class="paragraph data-line-2317">
<p><strong>Using extern function to call external code</strong></p>
</div>
<div class="paragraph data-line-2319">
<p>Rust code might need to interact with code written in another 
language. Rust has a keyword, extern, that facilitates the creation and 
use of a Foreign Function Interface (FFI).</p>
</div>
<div class="listingblock data-line-2320">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="Rust" class="language-Rust hljs"><span class="hljs-comment">// integration with C language</span>
<span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">abs</span></span>(input: <span class="hljs-built_in">i32</span>) -&gt; <span class="hljs-built_in">i32</span>;
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">unsafe</span> {
        <span class="hljs-built_in">println!</span>(<span class="hljs-string">"Absolute value of -3 according to C: {}"</span>, abs(-<span class="hljs-number">3</span>));
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div></div>
</div>

<script src="index%20Archivos/a"></script>
<script src="index%20Archivos/a_003"></script>
<script src="index%20Archivos/a_004"></script>
<script src="index%20Archivos/a_002"></script>

<script>
    var soket = new SockJS("/ws");

    function refreshUI(data) {

        var $placeholder = $("#placeholder");
        $placeholder.html(data);

        document.querySelectorAll('pre code').forEach((block) => {
            hljs.highlightBlock(block);
        });

        prettyPrint();

    }

    soket.onmessage = function (e) {
        refreshUI(e.data);
    };

    soket.onerror = soket.onclose = function (e) {
        $(".row.connection-closed").show();
    };

</script>

</body></html>