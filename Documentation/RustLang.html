<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.17">
<meta name="author" content="Eduardo Tapia">
<title>Rust Programming Language</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="article toc2 toc-left data-line-1">
<div id="header">
<h1>Rust Programming Language</h1>
<div class="details">
<span id="author" class="author">Eduardo Tapia</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_overview">1. Overview</a>
<ul class="sectlevel2">
<li><a href="#_characteristics">1.1. Characteristics</a></li>
<li><a href="#_developer_tools_in_rust">1.2. Developer tools in Rust</a></li>
<li><a href="#_fields_on_rust">1.3. Fields on Rust</a></li>
<li><a href="#_compiling">1.4. Compiling</a></li>
</ul>
</li>
<li><a href="#_rust_fundamentals">2. Rust Fundamentals</a>
<ul class="sectlevel2">
<li><a href="#_variables">2.1. Variables</a></li>
<li><a href="#_data_types">2.2. Data Types</a></li>
<li><a href="#_strings">2.3. Strings</a></li>
<li><a href="#_operators">2.4. Operators</a></li>
<li><a href="#_functions_methods">2.5. Functions &amp; Methods</a></li>
<li><a href="#_failures">2.6. Failures</a></li>
<li><a href="#_scope">2.7. Scope {}</a></li>
<li><a href="#_loops">2.8. Loops</a></li>
</ul>
</li>
<li><a href="#_stack_heap">3. Stack &amp; Heap</a></li>
<li><a href="#_ownership">4. Ownership</a>
<ul class="sectlevel2">
<li><a href="#_ownership_rules">4.1. Ownership Rules</a></li>
<li><a href="#_interacting_with_data_move_if_heap_copy_if_stack">4.2. Interacting with data: Move if Heap, Copy if Stack.</a></li>
</ul>
</li>
<li><a href="#_reference_and_borrowing">5. Reference (&amp;) and borrowing</a>
<ul class="sectlevel2">
<li><a href="#_the_rules_of_references">5.1. The Rules of References</a></li>
<li><a href="#_borrowing">5.2. Borrowing</a></li>
<li><a href="#_mutable_references">5.3. Mutable references</a></li>
<li><a href="#_dangling_references">5.4. Dangling references</a></li>
</ul>
</li>
<li><a href="#_structures">6. Structures</a>
<ul class="sectlevel2">
<li><a href="#_tuple_structure">6.1. Tuple structure</a></li>
<li><a href="#_methods_2">6.2. Methods</a></li>
<li><a href="#_associated_functions">6.3. Associated functions</a></li>
<li><a href="#_derived_traits">6.4. Derived traits</a></li>
<li><a href="#_wheres_the_operator">6.5. Where’s the &#8594; Operator?</a></li>
</ul>
</li>
<li><a href="#_enums_and_pattern_matching">7. Enums and pattern matching</a>
<ul class="sectlevel2">
<li><a href="#_option_enum_vs_null">7.1. Option enum vs Null</a></li>
<li><a href="#_match">7.2. match</a></li>
<li><a href="#_if_let_concise_control_flow">7.3. if-let, concise control flow</a></li>
</ul>
</li>
<li><a href="#_managing_growing_projects_with_packages_crates_and_modules">8. Managing growing projects with packages, crates and modules</a>
<ul class="sectlevel2">
<li><a href="#_packages_and_crates">8.1. Packages and crates</a></li>
<li><a href="#_defining_modules_to_control_scope_and_privacy">8.2. Defining modules to control scope and privacy</a></li>
<li><a href="#_external_packages">8.3. External packages</a></li>
<li><a href="#_separating_modules_into_different_files">8.4. Separating modules into different files.</a></li>
</ul>
</li>
<li><a href="#_common_collections">9. Common collections</a>
<ul class="sectlevel2">
<li><a href="#_vectors">9.1. Vectors</a></li>
<li><a href="#_hash_maps">9.2. Hash Maps</a></li>
</ul>
</li>
<li><a href="#_error_handling">10. Error Handling</a>
<ul class="sectlevel2">
<li><a href="#_unrecoverable_errors_with_panic">10.1. Unrecoverable errors with panic!</a></li>
<li><a href="#_recoverable_errors_with_result">10.2. Recoverable errors with Result</a></li>
<li><a href="#_to_panic_or_not_to_panic">10.3. to panic! or not to panic!</a></li>
</ul>
</li>
<li><a href="#_generic_types_traits_and_lifetimes">11. Generic Types, Traits and Lifetimes</a>
<ul class="sectlevel2">
<li><a href="#_generic_data_types">11.1. Generic Data Types</a></li>
<li><a href="#_traits_defining_shared_behavior">11.2. Traits: Defining shared behavior</a></li>
<li><a href="#_traits_as_parameters">11.3. Traits as parameters</a></li>
<li><a href="#_validating_references_with_lifetimes">11.4. Validating references with Lifetimes</a></li>
<li><a href="#_predictable_lifetime_by_elision_rules">11.5. Predictable Lifetime by elision rules</a></li>
</ul>
</li>
<li><a href="#_writing_automated_test">12. Writing automated test</a>
<ul class="sectlevel2">
<li><a href="#_how_to_write_tests">12.1. How to write tests</a></li>
<li><a href="#_controlling_how_test_are_run">12.2. Controlling how test are run</a></li>
<li><a href="#_test_organization">12.3. Test organization</a></li>
</ul>
</li>
<li><a href="#_functional_features_closures_and_iterators">13. Functional features: Closures and Iterators</a>
<ul class="sectlevel2">
<li><a href="#_closures">13.1. Closures</a></li>
<li><a href="#_closure_features">13.2. Closure features</a></li>
<li><a href="#_cache_storing_closures_using_generic_parameters_and_traits">13.3. Cache: Storing closures using generic parameters and traits</a></li>
<li><a href="#_capturing_environment_with_closures">13.4. Capturing environment with closures</a></li>
<li><a href="#_iterators">13.5. Iterators</a></li>
</ul>
</li>
<li><a href="#_more_about_cargo_and_crates_io">14. More about Cargo and Crates.io</a>
<ul class="sectlevel2">
<li><a href="#_customizing_builds_with_release_profiles">14.1. Customizing builds with release profiles</a></li>
<li><a href="#_documenting_and_publishing_a_crate_to_crates_io">14.2. Documenting and publishing a Crate to Crates.io</a></li>
<li><a href="#_cargo_workspaces">14.3. Cargo workspaces</a></li>
</ul>
</li>
<li><a href="#_smart_pointers">15. Smart Pointers</a>
<ul class="sectlevel2">
<li><a href="#_using_boxt_to_point_to_data_on_the_heap">15.1. Using Box&lt;T&gt; to Point to Data on the Heap</a></li>
<li><a href="#_implementing_dereference_trait">15.2. Implementing Dereference trait</a></li>
<li><a href="#_drop_trait">15.3. Drop Trait</a></li>
<li><a href="#_rct_the_reference_counted_smart_pointer">15.4. RC&lt;T&gt; the reference counted smart pointer</a></li>
<li><a href="#_refcellt_interior_mutability_pattern">15.5. RefCell&lt;T&gt; interior mutability pattern</a></li>
<li><a href="#_memory_leaks">15.6. Memory leaks</a></li>
</ul>
</li>
<li><a href="#_fearless_concurrencyand_or_parallel">16. Fearless Concurrency(and or parallel)</a>
<ul class="sectlevel2">
<li><a href="#_using_threads_to_run_code_simultaneously">16.1. Using threads to run code simultaneously</a></li>
<li><a href="#_using_message_passing_to_transfer_data_between_threads">16.2. Using message passing to transfer data between threads</a></li>
<li><a href="#_shared_state_concurrency">16.3. Shared-state Concurrency</a></li>
<li><a href="#_embedded_concurrency_with_sync_and_send_traits">16.4. Embedded concurrency with Sync and Send traits</a></li>
</ul>
</li>
<li><a href="#_object_oriented_programming">17. Object Oriented Programming</a>
<ul class="sectlevel2">
<li><a href="#_using_trait_objects_allow_values_of_different_types">17.1. Using trait objects: Allow values of different types</a></li>
<li><a href="#_implementing_object_oriented_design_pattern">17.2. Implementing Object-Oriented design pattern</a></li>
</ul>
</li>
<li><a href="#_patterns_and_matching">18. Patterns and Matching</a>
<ul class="sectlevel2">
<li><a href="#_patterns_use_cases">18.1. Patterns use cases</a></li>
<li><a href="#_refutability_wether_a_pattern_might_fail_or_match">18.2. Refutability: wether a pattern might Fail or match</a></li>
</ul>
</li>
<li><a href="#_advanced_features">19. Advanced features</a>
<ul class="sectlevel2">
<li><a href="#_unsafe_rust">19.1. Unsafe Rust</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1 data-line-13">
<h2 id="_overview">1. Overview</h2>
<div class="sectionbody">
<div class="sect2 data-line-14">
<h3 id="_characteristics">1.1. Characteristics</h3>
<div class="ulist data-line-15">
<ul>
<li class="data-line-15">
<p>Precompiled just like C.</p>
</li>
<li class="data-line-16">
<p>zero-cost abstractions: higher-level features that compile to lower-level code as fast as code written manually.</p>
</li>
<li class="data-line-17">
<p>Includes the official building system &amp; packet manager <strong>Cargo</strong>, allowing the user to control and build dependencies.</p>
</li>
<li class="data-line-18">
<p><strong>Snake case</strong> as the conventional style for function and variable names. In snake case, all letters are lowercase and underscores separate words. E.g. variable_name;</p>
</li>
</ul>
</div>
</div>
<div class="sect2 data-line-20">
<h3 id="_developer_tools_in_rust">1.2. Developer tools in Rust</h3>
<div class="ulist data-line-21">
<ul>
<li class="data-line-21">
<p><strong>Cargo</strong>: the included dependency manager and build tool(similar to Makefile but native), makes adding, compiling, and managing dependencies painless and consistent across the Rust ecosystem.
Cargo has a mechanism that ensures you can rebuild the same artifact every build (Cargo.TOML). Cargo will use only the versions of the dependencies you specified until you indicate otherwise. To ignore manual versions or to upgrade a package use <span class="underline">cargo update</span> (-update_only_optional_Packet) which will update dependencies to latest versions.</p>
</li>
<li class="data-line-23">
<p><strong>Rustfmt</strong>: ensures a consistent coding style across developers.</p>
</li>
<li class="data-line-24">
<p>The Rust <strong>Language Server</strong>: powers Integrated Development Environment (IDE) integration for code completion and inline error messages.</p>
</li>
<li class="data-line-25">
<p><strong>Crate</strong>: collection of Rust source code files (Basically a library).</p>
</li>
<li class="data-line-26">
<p>The <strong>Prelude</strong> is the most basic library that possesses the minimum functionalities that Rust need to import into every program, it includes traits of fundamental types, destructors and overloading, heap allocation, ownership, clone, comparison traits, generic conversions, iterators, heap allocated strings and vectors.</p>
</li>
</ul>
</div>
</div>
<div class="sect2 data-line-28">
<h3 id="_fields_on_rust">1.3. Fields on Rust</h3>
<div class="paragraph data-line-29">
<p>Command line tools, web services, DevOps tooling, embedded devices, audio and video analysis and transcoding, cryptocurrencies, bioinformatics, search engines, Internet of Things applications, machine learning, and even major parts of the Firefox web browser.</p>
</div>
</div>
<div class="sect2 data-line-31">
<h3 id="_compiling">1.4. Compiling</h3>
<table class="tableblock frame-all grid-all stretch data-line-35">
<caption class="title">Table 1. Compiling your project</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Instruction</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo new {name} <br>
    --lib</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Generates the packet manager folder for Cargo to manage your rust project<br>
   &#8201;&#8212;&#8201;Creates a library(lib.rs)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo build<br>
--release<br>
--target {TRIPLET}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Compiles Rust program and creates an executable file in target/debug folder<br>
&#8201;&#8212;&#8201;Compiles with optimizations (superfast code however is slower compilation time)<br>
&#8201;&#8212;&#8201;Cross-compiles for a target denoted by the TRIPLET. E.g. thumbv7m-none-eabi</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">./target/debug/{Cargo_File}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Runs the program stored on the Default path of the project, once Cargo builds the project.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo run</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Builds and runs the program in one step.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo check</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Check correct compiling without producing an executable (speed-up the process)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Import library</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cargo readobj --bin {project}<br>
&#8201;&#8212;&#8201;-file-headers</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">can print the ELF headers to confirm that this is an ARM binary</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo-size --bin {project} --release&#8201;&#8212;&#8201;-A</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">can print the size of the linker sections of the binary.</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cargo fmt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Reformats your code according community code style</p></td>
</tr>
</tfoot>
</table>
</div>
</div>
</div>
<div class="sect1 data-line-60">
<h2 id="_rust_fundamentals">2. Rust Fundamentals</h2>
<div class="sectionbody">
<div class="sect2 data-line-61">
<h3 id="_variables">2.1. Variables</h3>
<div class="paragraph data-line-62">
<p>let &#8594; Creates a variable.</p>
</div>
<div class="paragraph data-line-64">
<p>{}  &#8594; Curly brackets are the “format specifiers” (similar to % in C) of Rust. In Rust they are just a place holder.
E.g. Print to console</p>
</div>
<div class="listingblock data-line-67">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">a) println! ("x = {} and y = {}", x, y); 		// Prints the output to the screen.
b) let s = format! ("x = {} and y = {}", x, y);  	// Returns a String with the contents (but doesn’t print anything)</code></pre>
</div>
</div>
<div class="paragraph data-line-72">
<p>There exist a lot of format specifiers for rust, for example:</p>
</div>
<div class="listingblock data-line-74">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">println!("{} (U+{:04X}) ", c, c as u32);
$ cargo run --quiet -- "aimée" 	// a (U+0061) i (U+0069) m (U+006D) é (U+00E9) e (U+0065)</code></pre>
</div>
</div>
<div class="paragraph data-line-78">
<p>{:02X} – for individual bytes (change 2&#8594;4 for hexadecimals)</p>
</div>
</div>
<div class="sect2 data-line-80">
<h3 id="_data_types">2.2. Data Types</h3>
<div class="paragraph data-line-81">
<p>Rust is a statically typed language, which means that it must know the types of all variables at compile time.  The compiler can usually infer what type we want to use based on the value and how we use it. In cases when many types are possible, such as when converting a String to a numeric type using parse, we must add a type annotation.</p>
</div>
<div class="sect3 data-line-83">
<h4 id="_boolean_type">2.2.1. Boolean type</h4>
<div class="paragraph data-line-84">
<p>In Rust, Booleans are <span class="red">one byte</span> in size. Boolean type is specified by bool keyword: <code>let f: bool = false;</code></p>
</div>
<div class="listingblock data-line-86">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">E.g. let number = 3;
if number { println!("number was three"); }	//Error: expected bool, found integer</code></pre>
</div>
</div>
<div class="paragraph data-line-90">
<p>Rust will <span class="red">not automatically</span> try to convert non-Boolean types to a Boolean, it must be explicit and provide a Boolean value for safety. Note that "if" does not require parenthesis.</p>
</div>
</div>
<div class="sect3 data-line-92">
<h4 id="_rusts_char_type">2.2.2. Rust’s char type</h4>
<div class="paragraph data-line-93">
<p>Char is <span class="red">always 4 bytes</span> in size that uses <span class="blue">codepoint&#8592;&#8594;UTF-8</span> (encoding method that uses 1-4 one-byte code units(Basically UTF-8 up to 4 bytes)) to represent Unicode characters(Unicode is a standard, which defines a map from characters to numbers, the so-called code points). Which means it can represent a lot more than just ASCII, like emojis with his 1,112,064 valid characters. However, <span class="underline">in a char not always the 4 bytes have information</span>. In UTF-8 encoding, the higher part indicates the #ofBytes needed to store the symbol ranging from 1 to 4 bytes:</p>
</div>
<div class="ulist data-line-95">
<ul>
<li class="data-line-95">
<p>If a byte starts with 0 it means <span class="blue">only one byte</span>(128 different combinations) has information. For retrocompatibility, this characters represent the same 128 first characters as ASCII.</p>
</li>
<li class="data-line-96">
<p>If a byte starts with 110 it means we’ll use two bytes</p>
</li>
<li class="data-line-97">
<p>If a byte starts with 1110 it means we&#8217;ll use three bytes</p>
</li>
<li class="data-line-98">
<p>If a byte starts with 11110 it means we&#8217;ll use four bytes</p>
</li>
<li class="data-line-99">
<p>If a byte starts with 10, it means it&#8217;s a continuation of a multi-byte character sequence.</p>
</li>
</ul>
</div>
<table class="tableblock frame-all grid-all stretch data-line-104">
<caption class="title">Table 2. Code point &lt;&#8594; UTF-8 conversion</caption>
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.6666%;">
<col style="width: 16.667%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">First code point</th>
<th class="tableblock halign-left valign-top">Last code point</th>
<th class="tableblock halign-left valign-top">Byte 1</th>
<th class="tableblock halign-left valign-top">Byte 2</th>
<th class="tableblock halign-left valign-top">Byte 3</th>
<th class="tableblock halign-left valign-top">Byte 4</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+0000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+007F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xxxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+0080</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+07FF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">110xxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+0800</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+FFFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1110xxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+10FFFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11110xxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-111">
<p>The following example encodes “é” by using 2 bytes(right align), leftover bits are filled with 0 (called padding).</p>
</div>
<div class="imageblock data-line-114">
<div class="content">
<img src="images/images/1_Encoding.png" alt="1 Encoding">
</div>
<div class="title">Figure 1. Encoding “é” in UTF-8 (? Represents a free bit for data)</div>
</div>
</div>
<div class="sect3 data-line-117">
<h4 id="_integer_type">2.2.3. Integer type</h4>
<div class="paragraph data-line-118">
<p>An integer is a number without a fractional component. It can be type annotated as follows:</p>
</div>
<div class="listingblock data-line-119">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let number = 13;		//implicit data type
let number: i32 = 13;	//explicit data type</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all data-line-127" style="width: 50%;">
<caption class="title">Table 3. Integer types</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Length</th>
<th class="tableblock halign-left valign-top">Signed</th>
<th class="tableblock halign-left valign-top">Unsigned</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8-bit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">i8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">u8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">16-bit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">i16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">u16</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">32-bit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">i32</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">u32</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">64-bit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">i64</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">u64</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">128-bit</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">i128</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">u128</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Arch (Architecture dependent)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">isize</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">usize</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top" colspan="3"><p class="tableblock">Rust defaults integers to i32</p></td>
</tr>
</tfoot>
</table>
<table class="tableblock frame-all grid-all data-line-141" style="width: 50%;">
<caption class="title">Table 4. Number literals</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Number literals</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Decimal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">98_222</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Hex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xff</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Octal</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0o77</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Binary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0b1111_0000</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Byte (u8 only)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">b&#8217;A'</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-149">
<p>Signed numbers are stored using two’s complement representation. Furthermore, you can use “_” as a visual separator</p>
</div>
<div class="admonitionblock note data-line-152">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-153">
<p>Final note: Integer overflow</p>
</div>
<div class="ulist data-line-155">
<ul>
<li class="data-line-155">
<p>In debug mode, Rust includes checks for integer overflow that cause your program to panic at runtime if an overflow occurs.</p>
</li>
<li class="data-line-156">
<p>In release mode, rust doesn’t include checks. So, if overflow occurs, Rust performs two’s complement wrapping(256 becomes 0 in a u8). Relying on integer overflow is an error, you should explicitly handle these types of situation with wrapping_* methods(this is a reason why c produces unknown behaviors).</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3 data-line-159">
<h4 id="_float_type">2.2.4. Float type</h4>
<div class="paragraph data-line-160">
<p>f32(single precision) and f64(<strong>default</strong>, double precision) are used for numbers with decimal points. Floating-point numbers are represented according IEEE-754 standard.</p>
</div>
</div>
<div class="sect3 data-line-162">
<h4 id="_arrays_vs_vectors">2.2.5. Arrays vs Vectors</h4>
<div class="paragraph data-line-163">
<p><strong>Arrays</strong></p>
</div>
<div class="paragraph data-line-165">
<p>Arrays are useful when you want your data allocated on the <span class="green"><strong>stack</strong></span> rather than the heap or when you want to ensure you always have a <span class="underline">fixed</span> number of elements. E.g.</p>
</div>
<div class="listingblock data-line-167">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let a: [i32; 5] = [1, 2, 3, 4, 5];		 //array with type i32 with 5 elements.
let a = [3;5]			//array with 5 elements initialize with same value 3(due to “;”).</code></pre>
</div>
</div>
<div class="paragraph data-line-172">
<p>An array isn’t as flexible as the vector type though. A <strong>vector</strong> is a similar collection type provided by the standard library, it can grow or shrink in size(stored on <span class="green"><strong>heap</strong></span>).</p>
</div>
<div class="paragraph data-line-174">
<p><strong>Tuple</strong></p>
</div>
<div class="paragraph data-line-176">
<p>A tuple is a general way of <span class="underline">grouping together</span> several values with a variety of types into one compound type. Tuples have a fixed length: once declared, <span class="red">they cannot grow or shrink in size</span>.</p>
</div>
<div class="paragraph data-line-178">
<p>Tuples can be destructured(splitted) using patter matching and can be accessed using period “.”. E.g:</p>
</div>
<div class="listingblock data-line-179">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let tup: (i32, f64, u8) = (500, 6.4, 1);
let five_hundred = tup.0;
let six_point_four = tup.1;
let one = tup.2;</code></pre>
</div>
</div>
<div class="paragraph data-line-186">
<p><strong>Shadowing:</strong></p>
</div>
<div class="paragraph data-line-188">
<p>Shadowing let us reuse variables with same name, rather than forcing us to create two unique variables. The second variable’s value is what appears when the variable is used. It’s also possible to change the type of the variable since we’re effectively creating a new variable. E.g.</p>
</div>
<div class="listingblock data-line-190">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let word = “Hello”; 	//word is type string slice (&amp;str)
let word = word.len();   	//word is type usize with value 5</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-194">
<h3 id="_strings">2.3. Strings</h3>
<div class="paragraph data-line-195">
<p>The <span class="blue"><strong>String</strong></span> type is the most common type that has ownership over his contents, it’s growable and <span class="blue">UTF-8 encoded</span>, so it has a variable length that range from 1 and up to 6 bytes(the 8 in UTF-8 refers to the size of the code unit, which is 8 bits. For UTF-16 its 16 bits and so on). Rust ensure this and panics if you try to put invalid UTF-8 symbols).</p>
</div>
<table class="tableblock frame-all grid-all stretch data-line-199">
<caption class="title">Table 5. UTF-8 (1993)[2]. (x represents data)*</caption>
<colgroup>
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1111%;">
<col style="width: 11.1112%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">#of Bytes</th>
<th class="tableblock halign-left valign-top">First code point</th>
<th class="tableblock halign-left valign-top">Last code point</th>
<th class="tableblock halign-left valign-top">Byte 1</th>
<th class="tableblock halign-left valign-top">Byte 2</th>
<th class="tableblock halign-left valign-top">Byte 3</th>
<th class="tableblock halign-left valign-top">Byte 4</th>
<th class="tableblock halign-left valign-top">Byte 5</th>
<th class="tableblock halign-left valign-top">Byte 6</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+0000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+007F</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0xxxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+0080</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+07FF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">110xxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+0800</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+FFFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1110xxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+10000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+10FFFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11110xxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+200000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+3FFFFFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">111110xx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+4000000</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">U+7FFFFFFF</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1111110x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10xxxxxx</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-210">
<p>Memory is requested from the memory allocator at <span class="red">runtime</span> and returned(drop) via ownership system. To create a String(mutable) from a <span class="underline"><strong>string literal</strong></span>(immutable, known and hardcoded into de executable at compile time (string literals are inside “” symbol)):</p>
</div>
<div class="listingblock data-line-212">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let mut s = String::from("hello"); 	//creates a String from a string literal “hello”
s.push_str(", world!"); 		// push_str() appends a literal to a String
println!("{}", s);			 // This will print `hello, world!`</code></pre>
</div>
</div>
<div class="paragraph data-line-217">
<p>Strings are implemented as a Collection of bytes, plus some methods that provide functionality to those bytes when interpreted as text. Rust has ONLY ONE string type in the core language which is <span class="red">STRING SLICE</span> (str); the String type is provided as part of Rusts Standard Library rather than the core. However, both, String and str are UTF-8 encoded.</p>
</div>
<div class="paragraph data-line-219">
<p><span class="red">Indexing isn’t allowed</span> on Strings because UTF-8 symbols may take more than 1 byte so, invalid character may show up if we tried to return only 1 byte as the following example:</p>
</div>
<div class="listingblock data-line-220">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let s1 = String::from("♥");
let h = s1[0];	 // Rust doesn’t compile indexing on Strings
//However, if you really want to use indexing, you can use string slices using the range of the slice. Note that this indexing MUST occur at UTF-8 valid characters boundaries so you cannot just read 1 byte of the multibyte heart emoji(3 bytes).
let len = s1.len();
let indexing = &amp;s1[0..len];</code></pre>
</div>
</div>
<div class="paragraph data-line-228">
<p><strong>Iterating Over Strings</strong></p>
</div>
<div class="paragraph data-line-230">
<p>Since indexing Strings is out of the table, the recommendation is to access elements as char or bytes.</p>
</div>
<table class="tableblock frame-all grid-all stretch data-line-234">
<caption class="title">Table 6. Interpreting Strings</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">As chars</th>
<th class="tableblock halign-left valign-top">As bytes</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">for c in "न म स्ते".chars() {print!("{}", c);	//  न म स स्ते</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">for b in "न म स्ते".bytes() {println!("{},", b);         // 224,164..135</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-240">
<p>Strings are hard because: propensity for exposing errors in compile time, complicated structure, and UTF-8. But this will prevent you from having to handle errors involving non-ASCII characters.</p>
</div>
<div class="sect3 data-line-242">
<h4 id="_slice_typecommonly_used_as_str">2.3.1. Slice Type(commonly used as &amp;str)</h4>
<div class="paragraph data-line-243">
<p>At the most basic, a slice is a pointer to a block of memory. Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection(for example a part of an array or vector).</p>
</div>
<div class="paragraph data-line-245">
<p>A String slice(&amp;str) can be a reference pointing to an specific point of the binary(string literal) or a reference to part of a String(heap). So, <span class="blue">String slices</span> allows indexing on <span class="green">Strings or string literals</span>, however, they must occur at valid UTF-8 character boundaries. Slice method <span class="blue">from</span> in String tracks a starting and an ending index. E.g.</p>
</div>
<div class="listingblock data-line-246">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let s = String::from("hello world");
let hello = &amp;s[0..5];
let world = &amp;s[6..11];</code></pre>
</div>
</div>
<div class="paragraph data-line-251">
<p>Slice Program: write a function that takes a string and returns the first word it finds in that string</p>
</div>
<div class="listingblock data-line-252">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">fn first_word(s: &amp;String) -&gt; &amp;str {
let bytes = s.as_bytes();		// Convert our String to an array of bytes
/* iter is a method that returns each element in a collection and that enumerate wraps the result of iter and returns each element as part of a tuple instead */
    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {  		//search for byte that represents the “space” (this uses byte literal).
            return &amp;s[0..i]; }  }
    &amp;s[..] }</code></pre>
</div>
</div>
<div class="paragraph data-line-262">
<p><strong>The advantage of using slices</strong></p>
</div>
<div class="ulist data-line-264">
<ul>
<li class="data-line-264">
<p>Validity is ensured by lifetimes: since its referencing memory, the memory must be valid so its safer than Strings.</p>
</li>
<li class="data-line-265">
<p>Borrowing rules apply: so no data races occur.</p>
</li>
<li class="data-line-266">
<p>More generic data type: it can reference string literals or Strings so its widely used in APIs.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-268">
<h4 id="_two_types_of_strings_string_vs_str_and_the_implications_of_not_having_this_on_c_language">2.3.2. Two types of strings: String vs %str (and the implications of not having this on C language)</h4>
<div class="paragraph data-line-269">
<p><a href="https://fasterthanli.me/blog/2020/working-with-strings-in-rust/" class="undefined" data-href="https://fasterthanli.me/blog/2020/working-with-strings-in-rust/">https://fasterthanli.me/blog/2020/working-with-strings-in-rust/</a></p>
</div>
<div class="paragraph data-line-271">
<p>Basically, this article says that in Rust, <span class="green">String</span> type values are always UTF-8 valid symbols because you get an error otherwise. It is heap-allocated.
&amp;str refer to data from anywhere: heap, stack or even program’s data segment.</p>
</div>
<div class="paragraph data-line-274">
<p><strong>The implications of not having String on C</strong></p>
</div>
<div class="paragraph data-line-276">
<p>By comparison, <span class="red">C has no string type. It doesn&#8217;t even have a real character type</span>. C char is.. an ASCII character plus an additional bit - effectively, <span class="red">it&#8217;s just a signed 8-bit integer: int8_t</span>.</p>
</div>
<div class="ulist data-line-278">
<ul>
<li class="data-line-278">
<p>There is absolutely <span class="red">no guarantee that anything in a char* is a valid UTF-8</span>, or a valid something for that matter. There is no encoding associated to a char*, which is just an address in memory. There is <span class="red">no length</span> associated to it either, so computing its length involves finding the null terminator.</p>
</li>
<li class="data-line-279">
<p>Null-terminated strings are also a serious security concern. Not to mention that NULL is a valid Unicode character, so null-terminated strings cannot represent all valid UTF-8 strings.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2 data-line-281">
<h3 id="_operators">2.4. Operators</h3>
<div class="paragraph data-line-282">
<p>--mut:  Assigns mutable (modifiable, non-static content) attribute. In Rust variables are immutable by default to enforce safety and easy concurrency. E.g.:</p>
</div>
<div class="listingblock data-line-283">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let mut guess = 5;
match number1.cmp(&amp;number2) {
    Ordering::Less =&gt; println!("Number 1 is smaller"),
    Ordering::Greater =&gt; println!("Number 1 is larger!"),
	_ =&gt; (), 			//The “_” pattern will match any value.</code></pre>
</div>
</div>
<div class="paragraph data-line-290">
<p><strong>--match</strong>: allows us to compare a value against a series of patterns and then execute code based on which pattern matches. E.g. comparing returns an Ordering enum with 3 possible values: Less, Greater, Equal. Note that match is exhausting so all cases must be handled ( in case you want to handle remaining cases “_” place holder is a useful to match any pattern)</p>
</div>
<div class="paragraph data-line-292">
<p><strong>--const</strong>: constants are ALWAYS immutable. Furthermore, constants require annotated type and can only be set to a constant expression computed in compile time. <code>const MAX_POINTS: u32 = 100_000;		//100,000</code>
In Rust, constants use all upercase with underscores. Also, underscores can be inserted in numeric literals to improve readability.</p>
</div>
</div>
<div class="sect2 data-line-296">
<h3 id="_functions_methods">2.5. Functions &amp; Methods</h3>
<div class="sect3 data-line-297">
<h4 id="_functions">2.5.1. Functions</h4>
<div class="paragraph data-line-299">
<p>Rust doesn’t care where you define your functions, only that they’re defined somewhere (unlike C, where you must define a function before use it).
In function signatures, you must declare the type of each parameter, this means in the annotated form. E.g.</p>
</div>
<div class="listingblock data-line-301">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">fn example_function(x: i32, y: i32) {
    println!(“value of x is: {}”, x) …}</code></pre>
</div>
</div>
<div class="paragraph data-line-305">
<p><strong>Functions with returning values:</strong></p>
</div>
<div class="paragraph data-line-307">
<p>Return type goes after an arrow (&#8594;). Functions can return early by using the return keyword and specifying a value, but most functions return the last expression implicitly, by not adding semicolon (this means that this is the return value expression).</p>
</div>
<div class="listingblock data-line-308">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">fn plus_one(x: i32) -&gt; i32 { x + 1  }		//no semicolon, so it returns x + 1
plus_one(5); 	//6</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-312">
<h4 id="_methods">2.5.2. Methods</h4>
<div class="paragraph data-line-313">
<p>Methods are similar to functions, they can have parameters, return value</p>
</div>
<div class="paragraph data-line-315">
<p><code>object::method()</code> &#8594; "method" is an associated function of an object type (static method). “::” is like namespace where 2 methods equally named are totally different if they namespace is different. E.g:</p>
</div>
<div class="listingblock data-line-316">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let guess = String::new();		//method that creates a new instance of a String
instance::method.submethod() -&gt; Calls sub-method on method handle. E.g.: io::stdin().read_line();</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-320">
<h3 id="_failures">2.6. Failures</h3>
<div class="paragraph data-line-321">
<p><span class="blue">Result</span> types are enumerations. For Result, the variants are Ok or Err. The Ok variant indicates the operation was successful, and inside Ok is the successfully generated value. The Err variant means the operation failed and Err contains information about how or why the operation failed. The purpose of these Result types is to encode error-handling information.</p>
</div>
<div class="paragraph data-line-323">
<p><code>E.g.: func().expect(“failed”)</code> &#8594; <span class="blue">expect</span> Unwraps a result, yielding the content of an Ok. Otherwise panics and includes message and content of Err.</p>
</div>
</div>
<div class="sect2 data-line-325">
<h3 id="_scope">2.7. Scope {}</h3>
<div class="paragraph data-line-326">
<p>A scope is the range within a program for which an item is valid.</p>
</div>
</div>
<div class="sect2 data-line-328">
<h3 id="_loops">2.8. Loops</h3>
<table class="tableblock frame-all grid-all stretch data-line-333">
<caption class="title">Table 7. Loops</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">For</th>
<th class="tableblock halign-left valign-top">While</th>
<th class="tableblock halign-left valign-top">Loop</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Increased  safety of the code and eliminated the chance of bugs that might result from going beyond the end of the array or not going far enough and missing some items.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Useful to evaluate a condition within a loop. However, is slower because the compiler adds runtime code to perform the conditional check on every element on every iteration through the loop.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Executes a block of code over and over again forever or until you explicitly tell it to stop.</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">let a = [10, 20, 30, 40, 50];</p>
<p class="tableblock">for element in a.iter() {</p>
<p class="tableblock">println!("the value is: {}", element);}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">let mut number = 3;</p>
<p class="tableblock">while number != 0 {</p>
<p class="tableblock">println!("{}!", number); number -= 1; }</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">loop {println!("again!";}</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-351">
<p>Note: Loops can return a value with the break statement</p>
</div>
<div class="listingblock data-line-352">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">Let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2;
    }
};				// the ; makes the loop a statement, assigning the counter value to result.</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-361">
<h2 id="_stack_heap">3. Stack &amp; Heap</h2>
<div class="sectionbody">
<div class="paragraph data-line-362">
<p>Stack-allocated data has a known, fixed size, LIFO.</p>
</div>
<div class="paragraph data-line-364">
<p>Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p>
</div>
<div class="paragraph data-line-366">
<p>The heap is less organized: when you put data on the heap, you request a certain amount of space. The operating system finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. This process is called allocating on the heap and is sometimes abbreviated as just allocating. Pushing values onto the stack is not considered allocating. Because the pointer is a known, fixed size, you can store the pointer on the stack, but when you want the actual data, you must follow the pointer.</p>
</div>
</div>
</div>
<div class="sect1 data-line-368">
<h2 id="_ownership">4. Ownership</h2>
<div class="sectionbody">
<div class="paragraph data-line-369">
<p>All programs must manage the way they use a computer’s memory while running. Some languages have <span class="underline">garbage collection</span> that constantly looks for no longer used memory as the program runs; in other languages, the programmer must explicitly <span class="underline">allocate and free the memory</span>. Rust uses a third approach: memory is managed through a <span class="green"><strong>system of ownership</strong></span> with a set of rules that the compiler checks at compile time. None of the ownership features slow down your program while it’s running.</p>
</div>
<div class="sect2 data-line-371">
<h3 id="_ownership_rules">4.1. Ownership Rules</h3>
<div class="ulist data-line-373">
<ul>
<li class="data-line-373">
<p>Each value in Rust has a variable that’s called its owner.</p>
</li>
<li class="data-line-374">
<p>There can only be one owner at a time.</p>
</li>
<li class="data-line-375">
<p>When the owner goes out of scope, the value will be dropped hence the memory is freed.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-378">
<p>Note: Ownership rules applies to variables as well as functions.</p>
</div>
</div>
<div class="sect2 data-line-380">
<h3 id="_interacting_with_data_move_if_heap_copy_if_stack">4.2. Interacting with data: Move if Heap, Copy if Stack.</h3>
<div class="paragraph data-line-382">
<p>Rust will <span class="red">never</span> automatically create “deep” copies of your heap allocated data(because could result in poor performance). Instead Rust performs a “move” operation, on which:</p>
</div>
<div class="ulist data-line-384">
<ul>
<li class="data-line-384">
<p>Stack-allocated Data is Copied with an internal clone.</p>
</li>
<li class="data-line-385">
<p>Heap-allocated Data copies just the reference to the same location. It transfers ownership! So previous variable is invalidated(avoiding double free problem).</p>
</li>
</ul>
</div>
<div class="paragraph data-line-387">
<p>This way, the previous owner will not try to drop memory when goes out of scope because it’s invalid; the new owner will now oversee the value dropping.</p>
</div>
<div class="paragraph data-line-389">
<p>In the next example, known size values like length and capacity are stored on the Stack so they are copied; dynamic values like String ptr data is allocated on heap so only the pointer is copied, however ownership is passed as shown below.</p>
</div>
<div class="listingblock data-line-390">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let s1 = String::from("hello");   //String stores some values on Heap and some on Stack
let s2 = s1;			    //s1 is now invalid for safety. Now S2 has ownership</code></pre>
</div>
</div>
<div class="imageblock data-line-396">
<div class="content">
<img src="images/images/2_stackheap.jpg" alt="2 stackheap">
</div>
<div class="title">Figure 2. Representation in memory after s1 has been invalidated.</div>
</div>
<table class="tableblock frame-all grid-all stretch data-line-400">
<caption class="title">Table 8. Ownership functions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Pass copy</th>
<th class="tableblock halign-left valign-top">Pass ownership</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ x is created on <span class="red">stack</span></p>
<p class="tableblock">let x = 5; <br>
/ x (i32) is Copied into function
makes_copy(x); <br>
/x is still valid here</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/ s is created on the <span class="red">heap</span><br>
let s = String::from("hello");<br></p>
<p class="tableblock">/s pass ownership to the function&#8230;&#8203;(MOVE operation)<br>
take_ownership(s);<br>
/s is <span class="red">no longer valid</span> here</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-421">
<p>Note: To create a deep copy, including heap data, use clone() method. <code>let s2 = s1.clone();</code></p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-423">
<h2 id="_reference_and_borrowing">5. Reference (&amp;) and borrowing</h2>
<div class="sectionbody">
<div class="paragraph data-line-424">
<p>&amp; &#8594; Get memory address: operator that gets the memory address (in hexadecimal) of a piece of data.</p>
</div>
<div class="sect2 data-line-426">
<h3 id="_the_rules_of_references">5.1. The Rules of References</h3>
<div class="ulist data-line-427">
<ul>
<li class="data-line-427">
<p>At any given time, you can have either one mutable reference or any number of immutable references.</p>
</li>
<li class="data-line-428">
<p>References must always be valid(lifetime).</p>
</li>
<li class="data-line-429">
<p>References are immutable by default and the scope determines its validity.</p>
</li>
</ul>
</div>
</div>
<div class="sect2 data-line-431">
<h3 id="_borrowing">5.2. Borrowing</h3>
<div class="paragraph data-line-432">
<p>It’s also possible to<strong> use a value without taking ownership</strong>, by using references (&amp;), we call having references as function parameters borrowing. The scope in which the variable is valid isn’t affected by the borrowing variable/function, so we don’t have to drop what the reference points to when it goes out of scope because we didn’t had ownership in the first place.</p>
</div>
<div class="listingblock data-line-433">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">{
	let s1 = String::from("hello");		//s1 has ownership
	let len = calculate_length(&amp;s1);		//len borrows s1, and uses it.
						// s1 keeps having ownership
} 					       	 //s1 goes out of scope so is freed.
fn calculate_length(s: &amp;String) -&gt; usize { s.len()}</code></pre>
</div>
</div>
<div class="imageblock data-line-442">
<div class="content">
<img src="images/images/3_borrowing.jpg" alt="3 borrowing">
</div>
<div class="title">Figure 3. Variable s borrowing variable s1. These &amp; are references, and they allow you to refer to some value without taking ownership of it.</div>
</div>
<div class="paragraph data-line-444">
<p>The opposite of reference is dereference, which is accomplish with dereference operator (*) on <a href="#_smart_pointers">Smart Pointers</a>.</p>
</div>
</div>
<div class="sect2 data-line-446">
<h3 id="_mutable_references">5.3. Mutable references</h3>
<div class="paragraph data-line-447">
<p>Note that references are immutable by default, to create a mutable reference, just add &amp;mut s trait.</p>
</div>
<div class="paragraph data-line-449">
<p>A big restriction on mutable references is that you can have only <span class="underline">ONE mutable reference</span> to a value in the <span class="underline">same scope</span>, also is not possible to have mutable and immutable references in the same scope. This restriction allows mutation in a very controlled fashion, avoiding race conditions, simultaneous access to the same piece of data, synchronization problems and sudden changes.</p>
</div>
<div class="listingblock data-line-451">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let mut s = String::from("hello");

let r1 = &amp;s; 			//1 immutable reference, no problem
let r2 = &amp;s; 			//2 immutable references, no problem
println!("{} and {}", r1, r2)  			 // references to r1 and r2 will not be used after this point

let r3 = &amp;mut s; 		//1 mutable reference and no immutable ones, no problem</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-461">
<h3 id="_dangling_references">5.4. Dangling references</h3>
<div class="paragraph data-line-462">
<p>if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does, at <span class="green">compile time!</span>(using lifetimes).</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-464">
<h2 id="_structures">6. Structures</h2>
<div class="sectionbody">
<div class="paragraph data-line-465">
<p>Like tuples, structures can group many data types together. However, structures doesn´t rely on data order  declaration. Structs own its data so data referenced by a struct is valid as long as struct is.</p>
</div>
<div class="listingblock data-line-466">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">struct User {
  	 username: String,
   	 email: String,
   	 sign_in_count: u64,
   	 active: bool,
}</code></pre>
</div>
</div>
<div class="paragraph data-line-474">
<p><strong>Instance</strong></p>
</div>
<div class="paragraph data-line-476">
<p>Instances are declared using key:value pairs, luckily there is a <span class="underline">shorthand notation</span> when variables and fields have the <strong>same Name</strong> (email: email &#8594; email) Rust automatically assigns them. Access to a specific field is granted through dot notation. Entire instance should be mutable, Rust <span class="red">does´t allow to mark only certain fields as mutable.</span></p>
</div>
<div class="listingblock data-line-478">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
let user1 = build_user(String::from( “Eduardo”), String::from( “Tapia”));
user1.active = false;</code></pre>
</div>
</div>
<div class="paragraph data-line-491">
<p><strong>Struct update syntax</strong>
It is possible to create a new instance that uses values of an existing one. And there is also a shorthand notation presented to set the remaining fields with another instance using “..” .</p>
</div>
<div class="listingblock data-line-493">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let user2 = User {
    email: String::from( “etapia.clr@gmail.com”),
    username: String::from( “Killerpug”),
	..user1				//remaining field on user2 are the same as user1.
};</code></pre>
</div>
</div>
<div class="paragraph data-line-501">
<p>Note: to update struct use dot notation. E.g: <code>user1.email = String::from(“<a href="mailto:etapia@gmail.com" data-href="mailto:etapia@gmail.com">etapia@gmail.com</a>”);</code>. We use String to OWN the data.</p>
</div>
<div class="sect2 data-line-503">
<h3 id="_tuple_structure">6.1. Tuple structure</h3>
<div class="paragraph data-line-505">
<p>Tuple structs have the added meaning the struct name provides, but don’t have names associated with their fields.</p>
</div>
<div class="listingblock data-line-506">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">struct 3DPoint(i32, i32, i32);
let origin = 3DPoint(0, 0, 0);</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-510">
<h3 id="_methods_2">6.2. Methods</h3>
<div class="paragraph data-line-511">
<p>Methods only differ from functions because they are defined within the context(<span class="blue">impl</span>) of the struct and their first parameter is always <span class="green">self</span>, which represents the instance of the struct the method is being called on.</p>
</div>
<div class="listingblock data-line-512">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">impl Rectangle {
    fn area(&amp;self) -&gt; u32 {		//add &amp;mut self if you want to modify the struct
        self.width * self.height
    }
}
Let rect1 = Rectangle { width: 30, height:50,};	//creating a Rectangle instance
Rect1.area();				//calling the area method</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-522">
<h3 id="_associated_functions">6.3. Associated functions</h3>
<div class="paragraph data-line-523">
<p>We’re allowed to define functions within impl blocks that <span class="underline">don’t take self as a parameter</span>, these are called associated functions(still functions, not methods). Associated functions are often used for constructors that will return a new instance of the struct. To call this associated function, use the namespace“::” notation. E.g.</p>
</div>
<div class="listingblock data-line-524">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {		//no self
        Rectangle { width: size, height: size }
    }
}
  let sq = Rectangle::square(3);</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-533">
<h3 id="_derived_traits">6.4. Derived traits</h3>
<div class="paragraph data-line-534">
<p>The <span class="blue">println!</span> macro can do many kinds of formatting, and by default, the curly brackets tell println! to use formatting known as Display (output intended for direct end user consumption). For primitive types we’ve seen so far there’s only one way you’d want to show them. But <strong>with structs</strong>, <span class="underline">the way println! should format the output is less clear because there are <strong>more display possibilities</strong></span>: Do you want commas or not? Do you want to print the curly brackets? Should all the fields be shown? Due to this ambiguity, Rust doesn’t try to guess what we want, and <span class="red">structs don’t have a provided implementation of Display.</span></p>
</div>
<div class="listingblock data-line-535">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">println!("rect1 is {:?}", rect1);</code></pre>
</div>
</div>
<div class="paragraph data-line-538">
<p>Putting the specifier <strong>:?</strong> inside the curly brackets tells println! we want to use an output format called Debug. The <strong>Debug trait</strong> enables us to print our struct in a way that is useful for developers so we can see its value while we’re debugging our code.
Rust does include functionality to print out debugging information, but we have to explicitly make that functionality available for our struct. To do that, we add the annotation #[derive(Debug)] just before the struct definition.</p>
</div>
<div class="listingblock data-line-540">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("rect1 is {:?}", rect1);
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-552">
<h3 id="_wheres_the_operator">6.5. Where’s the &#8594; Operator?</h3>
<div class="paragraph data-line-553">
<p>In C and C++, two different operators are used for calling methods: you use “.” if you’re calling a method on the object directly and &#8594; if you’re calling the method on a pointer to the object and need to dereference the pointer first. In other words, if object is a pointer, object&#8594;something() is similar to (*object).something().</p>
</div>
<div class="paragraph data-line-555">
<p>Rust doesn’t have an equivalent to the &#8594; operator; instead, Rust has a feature called <span class="green"><strong>automatic referencing and dereferencing</strong></span>. Here’s how it works: when you call a method with object.something(), Rust automatically adds in &amp;, &amp;mut, or * so object matches the signature of the method. In other words, the following are the same:  <code>p1.distance(&amp;p2);  ==   (&amp;p1).distance(&amp;p2);</code></p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-557">
<h2 id="_enums_and_pattern_matching">7. Enums and pattern matching</h2>
<div class="sectionbody">
<div class="paragraph data-line-558">
<p>Enumerators allow us to enumerate all possibilities but only choosing one. It has some properties of structs as all variants should be treated as the same type, and enums also can have associated method and functions.</p>
</div>
<div class="listingblock data-line-559">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">//Simple Enum and usage
enum IpAddrKind {
    V4,
    V6,
}
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
// Note that the variants of the enum are namespaced under its identifier, allowing either: V4 or V6.
fn route(ip: IpAddrKind) { }


//Data embedded in the Enum(using tuple)
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}
let home = IpAddr::V4(192, 168, 50, 1);
let loopback = IpAddr::V6(String::from("::1"));
// Note: you can put any kind of data inside an enum variable, even a struct or another enum.</code></pre>
</div>
</div>
<div class="paragraph data-line-582">
<p><strong>Using methods and associated functions on Enums</strong></p>
</div>
<div class="paragraph data-line-584">
<p>Just as we’re able to define methods on structs using <span class="blue">impl</span>, we’re also able to define methods on enums. E.g.</p>
</div>
<div class="listingblock data-line-585">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

impl Message {
    fn call(&amp;self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from("hello"));		//::Write is namespaced in Message enum
m.call();</code></pre>
</div>
</div>
<div class="sect2 data-line-603">
<h3 id="_option_enum_vs_null">7.1. Option enum vs Null</h3>
<div class="paragraph data-line-604">
<p>The concept that null is trying to express is a useful one: <span class="underline">a null is a value that is currently invalid or absent for some reason</span>. Despite being <span class="red">implemented poorly on C</span>, where a null has led to innumerable errors, vulnerabilities, and system crashes. The problem with null values is that if you try to use a null value as a not-null value, you’ll get an error of some kind. This null property is pervasive because it’s extremely easy to make this kind of error.</p>
</div>
<div class="paragraph data-line-606">
<p>The problem radicates on the implementation. Rust <strong>does not have nulls</strong>, but it does have an enum that can encode the concept of a value being present or absent. This enum is <span class="green"><strong>Option&lt;T&gt;</strong></span>, and it is defined by the standard library(prelude) as follows:</p>
</div>
<div class="listingblock data-line-607">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">enum Option&lt;T&gt; {
    Some(T),
    None,
}
let some_string = Some("a string");		//presence
let absent_number: Option&lt;i32&gt; = None;	//abscense</code></pre>
</div>
</div>
<div class="paragraph data-line-615">
<p>Option is better than Null because Option&lt;T&gt; and T (where T can be any type) are different types, the compiler won’t let us use an Option&lt;T&gt; value as if it were definitely a valid value. In order to use an Option&lt;T&gt; value, you want to have code that will <span class="green"><strong>handle</strong></span> each variant of Option Enum.</p>
</div>
<div class="listingblock data-line-616">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let y: Option&lt;i8&gt; = Some(5);
let sum = 8 + y;	//Will not compile. Needs to handle Option&lt;i8&gt; Enum</code></pre>
</div>
</div>
<div class="paragraph data-line-620">
<p>Note: Option is strong with match to handle cases. In other word, you have to convert Option&lt;T&gt; to a T before perform operations with T.</p>
</div>
</div>
<div class="sect2 data-line-622">
<h3 id="_match">7.2. match</h3>
<div class="paragraph data-line-623">
<p><span class="blue">match</span> is a control flow operator that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. Patterns can be made up of literal values, variable names, wildcards and more. The power of match comes from the expressiveness of patterns and the fact that the compilers is exhaustive (ALL CASES MUST BE HANDLED).</p>
</div>
<div class="listingblock data-line-624">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
           Println!(“You inserted a penny”);
           1
         }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(UsState) =&gt; 25,
    }
}
enum UsState{ Alaska, Alabama, ….}	//remember that enums can embed data.</code></pre>
</div>
</div>
<div class="ulist data-line-645">
<ul>
<li class="data-line-645">
<p>&#8658;, separates the pattern to match and the code to run, in this case the code is just the value.</p>
</li>
<li class="data-line-646">
<p>_, wildcard that matches any value.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-648">
<p><strong>Match with Option&lt;T&gt;:</strong> function that takes an Option&lt;i32&gt; and, if there’s a value inside, adds 1 to that value. If there isn’t a value inside, the function should return the None value and not attempt to perform any operations.</p>
</div>
<div class="listingblock data-line-649">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-661">
<h3 id="_if_let_concise_control_flow">7.3. if-let, concise control flow</h3>
<div class="paragraph data-line-662">
<p><span class="blue">If let</span> allows us to combine if and let into a less verbose way to handle values that <span class="underline">match only one pattern while ignoring the rest</span>. Using if let means less typing, less indentation, and less boilerplate code. However, you lose the exhaustive checking that match enforces.</p>
</div>
<table class="tableblock frame-all grid-all stretch data-line-667">
<caption class="title">Table 9. Verbose pattern-match vs if-let for 1 case</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Verbose matching pattern, only 1 case is useful</th>
<th class="tableblock halign-left valign-top">Shorthand if let</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">let some_u8_value = Some(0u8);<br>
match some_u8_value {<br>
    Some(3) &#8658; println!("three"),<br>
    _ &#8658; (),</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">let some_u8_value = Some(0u8);<br>
if let Some(3) = some_u8_value {<br>
println!("three");</p></td>
</tr>
</tfoot>
</table>
</div>
</div>
</div>
<div class="sect1 data-line-679">
<h2 id="_managing_growing_projects_with_packages_crates_and_modules">8. Managing growing projects with packages, crates and modules</h2>
<div class="sectionbody">
<div class="paragraph data-line-680">
<p>As a project grows, you can organize code by splitting it into multiple modules and then multiple files. As a package grows, you can extract parts into separate crates that become external dependencies.</p>
</div>
<div class="paragraph data-line-682">
<p>Once you’ve implemented an operation, other code can call that code via the code’s public interface without knowing how the implementation works.</p>
</div>
<div class="paragraph data-line-684">
<p>Rust has features that allow you to manage your code’s organization, including which details are exposed(public), which details are private, and what names are in each scope in your programs. These features, sometimes collectively referred to as the module system, include:</p>
</div>
<div class="ulist data-line-686">
<ul>
<li class="data-line-686">
<p>Packages: A Cargo feature that lets you build, test, and share crates. A package can contain multiple binary crates and at most one library crate.</p>
</li>
<li class="data-line-687">
<p>Crates: A tree of modules that produces a library or executable</p>
</li>
<li class="data-line-688">
<p>Modules and use: blocks that let you control the organization, scope, and privacy of paths(private/public)</p>
</li>
<li class="data-line-689">
<p>Paths: A way of naming an item, such as a struct, function, or module</p>
</li>
</ul>
</div>
<div class="sect2 data-line-691">
<h3 id="_packages_and_crates">8.1. Packages and crates</h3>
<div class="paragraph data-line-692">
<p>When we create a new project via cargo new, Cargo creates the <span class="blue"><strong>Cargo.toml file giving us a package</strong></span>. there’s no mention of src/main.rs because Cargo follows a convention that <span class="blue"><strong>src/main.rs is the crate root of a binary</strong></span> crate with the same name as the package. Likewise, Cargo knows that <span class="green"><strong>if the package directory contains src/lib.rs, the package contains a library crate</strong></span> and  src/lib.rs is its crate root. Cargo passes the crate root files to rustc to build the library or binary. Finally because crates are namespaced, which means that they have their own scope so no confusion of which library function is being called.</p>
</div>
</div>
<div class="sect2 data-line-694">
<h3 id="_defining_modules_to_control_scope_and_privacy">8.2. Defining modules to control scope and privacy</h3>
<div class="paragraph data-line-695">
<p>To structure our crate, rust allows organization via nested modules, which improves readability because programmers can find definitions based on groups rather than having to reading all definitios. E.g: The <span class="underline">restaurant library</span>. In the restaurant industry, some parts of a restaurant are referred to as <span class="underline">front of house(public)</span> and others as <span class="underline">back of house(private)</span>.</p>
</div>
<div class="paragraph data-line-697">
<p>Front of house is where customers are, this is where hosts seat customers, servers take orders and payment, and bartenders make drinks. Back of house is where the chefs and cooks work in the kitchen, dishwashers clean up, and managers do administrative work.
 Create a new library named restaurant by running <code>cargo new --lib restaurant;</code>. Then define the module as:</p>
</div>
<div class="listingblock data-line-699">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">// crate lib.rs
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}	//Making the module public doesn’t make the contents public
        fn seat_at_table() {}	//private by default
    }

    mod serving {
        fn take_order() {}
        fn serve_order() {}
        fn take_payment() {}
    }
}
pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}</code></pre>
</div>
</div>
<div class="openblock tree data-line-722">
<div class="content">
<div class="paragraph data-line-723">
<p><mark>crate
<mark>front_of_house
</mark>#hosting
<mark></mark>#add_to_waitlist
</mark><mark>seat_at_table
</mark><mark>serving
<mark></mark>#take_order
</mark><mark>serve_order
</mark>##take_payment</p>
</div>
</div>
</div>
<div class="paragraph data-line-734">
<p>Note: Src/main.rs and src/lib.rs are called crate roots because the contents of these two form the root of the crate module tree. Modules are like filesystem’s directory tree on a computer.</p>
</div>
<div class="paragraph data-line-736">
<p><strong>Privacy</strong></p>
</div>
<div class="paragraph data-line-738">
<p>The way privacy works in Rust is that all items (functions, methods, structs, enums, modules, and constants) are private by default, which hides the inner implementation details and allow to control inner and outer code.
Pub keyword makes items public to the ancestor module.
Example:</p>
</div>
<div class="listingblock data-line-741">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">mod back_of_house {
    pub struct Breakfast {		//pub doesn’t make the fields in the structure public, (enums in contrast do)
        pub toast: String,
        seasonal_fruit: String,		// seasonal_fruit is still private
    }

    impl Breakfast {				//method associated to Breakfast structure
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from("peaches"),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer("Rye");
    // Change our mind about what bread we'd like
    meal.toast = String::from("Wheat");
    println!("I'd like {} toast please", meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal because its PRIVATE
    // meal.seasonal_fruit = String::from("blueberries");</code></pre>
</div>
</div>
<div class="paragraph data-line-769">
<p><strong>Paths</strong></p>
</div>
<div class="paragraph data-line-771">
<p>To find an item in a module tree, we use paths to navigate the filesystem. A path can take two forms:</p>
</div>
<div class="ulist data-line-773">
<ul>
<li class="data-line-773">
<p>An absolute path starts from a crate root by using a crate name or a literal crate. E.g: <code>crate::front_of_house::hosting::add_to_waitlist();</code></p>
</li>
<li class="data-line-776">
<p>A relative path starts from the current module and uses self, super, or an identifier in the current module.
Use keyword brings a path into scope to use them as if they were local items. E.g:</p>
</li>
</ul>
</div>
<div class="listingblock data-line-778">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use crate::front_of_house::hosting;
pub fn eat_at_restaurant(){ hosting::add_to_waitlist(); }</code></pre>
</div>
</div>
<div class="paragraph data-line-783">
<p><strong>Using multiple items</strong></p>
</div>
<div class="paragraph data-line-785">
<p>Importing multiple items like:</p>
</div>
<div class="listingblock data-line-786">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use std::cmp::Ordering;
use std::io;
// can be shorted as:
use std::{cmp::Ordering, io};</code></pre>
</div>
</div>
<div class="paragraph data-line-792">
<p>Note: Operator “ * ” specify all public items within a path.</p>
</div>
<div class="paragraph data-line-794">
<p><strong>Aliasing</strong></p>
</div>
<div class="paragraph data-line-796">
<p>As keyword allows aliasing paths to avoid conflict of 2 same named paths. E.g. <code>std::io::Result as IoResult;</code></p>
</div>
</div>
<div class="sect2 data-line-798">
<h3 id="_external_packages">8.3. External packages</h3>
<div class="paragraph data-line-799">
<p>Pulling external packages from crates.io involves:</p>
</div>
<div class="olist arabic data-line-801">
<ol class="arabic">
<li class="data-line-801">
<p>Listing the packages in the Cargo.toml file</p>
</li>
<li class="data-line-802">
<p>Bring the items into scope via use keyword</p>
</li>
</ol>
</div>
<div class="paragraph data-line-804">
<p>E.g:</p>
</div>
<div class="listingblock data-line-805">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">// 1. On Cargo.toml
[dependencies]
rand = "0.5.5";

// 2. On src/main.rs
use rand::Rng
fn main() {let secret_number = rand::thread_rng().gen_range(1, 101);}</code></pre>
</div>
</div>
<div class="paragraph data-line-814">
<p>Note: std is an external package but its shipped with Cargo so no need of listing it on the Cargo.toml</p>
</div>
</div>
<div class="sect2 data-line-816">
<h3 id="_separating_modules_into_different_files">8.4. Separating modules into different files.</h3>
<div class="paragraph data-line-817">
<p>When modules get large, you might want to separate the module with its own file. To do this:</p>
</div>
<div class="olist arabic data-line-819">
<ol class="arabic">
<li class="data-line-819">
<p>Put a <span class="red">semicolon</span> after mod front_of_house instead of a block, this tells Rust to load the contents of the module <span class="underline">from another file</span> with the same name as the module.</p>
</li>
<li class="data-line-820">
<p>Create the src/front_of_house directory and file src/front_of_house/hosting.rs to contain definitions of hosting module.</p>
</li>
</ol>
</div>
<div class="listingblock data-line-821">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">// On src/lib.rs
mod front_of_house;
pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}

// On src/front_of_house.rs
pub mod hosting; //declaration of module

// On src/front_of_house/hosting.rs
	pub fn add_to_waitlist() {}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-838">
<h2 id="_common_collections">9. Common collections</h2>
<div class="sectionbody">
<div class="paragraph data-line-839">
<p>Standard library includes data structures called collections which may contain multiple data types. <span class="green"><strong>Unlike built-in array and tuples</strong></span>, these <span class="red"><strong>collections are stored on the heap</strong>!</span>:</p>
</div>
<div class="ulist data-line-841">
<ul>
<li class="data-line-841">
<p>Vector: allows you to store a variable number of values of the same type in contiguous memory.</p>
</li>
<li class="data-line-842">
<p>String: is a collection of UTF-8 values.</p>
</li>
<li class="data-line-843">
<p>Hash map: allows you to associate a value with a particular key. It’s a particular implementation of the more general data structure called a map.</p>
</li>
</ul>
</div>
<div class="sect2 data-line-845">
<h3 id="_vectors">9.1. Vectors</h3>
<div class="sect3 data-line-846">
<h4 id="_creating_a_new_vector">9.1.1. Creating a new vector</h4>
<div class="listingblock data-line-847">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let mut v: Vec&lt;i32&gt; = Vec::new();	//Vec&lt;T&gt;, generic so it can hold any type
v.push(5);			  	// updating a vector

//or

let v = vec![1, 2, 3];		// macro to create vector with initial values, it infers type because we put some data.</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-856">
<h4 id="_reading_elements_of_vector">9.1.2. Reading elements of vector</h4>
<div class="ulist data-line-857">
<ul>
<li class="data-line-857">
<p>Vectors are indexed by number, starting at zero.</p>
</li>
<li class="data-line-858">
<p>Two ways of accessing an element:</p>
<div class="ulist data-line-859">
<ul>
<li class="data-line-859">
<p>Using <span class="blue">&amp; and [ ]</span>, which give us a reference.</p>
</li>
<li class="data-line-860">
<p>Using “<span class="blue">get</span>” method with the index passed as an argument, which give us an <span class="blue">Option&lt;&amp;T&gt;</span></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="listingblock data-line-861">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let v = vec![1, 2, 3, 4, 5];

// Access using reference
    let third: &amp;i32 = &amp;v[2];
    println!("The third element is {}", third);

//Access using get
    match v.get(2) {
        Some(third) =&gt; println!("The third element is {}", third),
        None =&gt; println!("There is no third element."),
    }</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-876">
<h4 id="_iterating_a_vector">9.1.3. Iterating a vector</h4>
<div class="paragraph data-line-877">
<p>We can also iterate over mutable references in order to change the elements.</p>
</div>
<div class="listingblock data-line-878">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let v = vec![100, 32, 57];
    for i in &amp;v {			//iterating over immutable reference
        println!("{}", i);

let mut v = vec![100, 32, 57];
    for i in &amp;mut v {
        *i += 50; } 		// dereference operator (*) to get to the value in i</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-889">
<h4 id="_using_enum_and_vector_to_store_multiple_types">9.1.4. Using Enum and vector to store multiple types</h4>
<div class="paragraph data-line-891">
<p>This makes use of the property that the variants of an enum are defined under the SAME ENUM TYPE :OO. However the disadvantage is that <span class="red">types have to be known at compile time(even thought is stored on heap)</span> or use a trait object discussed on <a href="#_object_oriented_programming">Object Oriented Programming</a>.</p>
</div>
<div class="listingblock data-line-892">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-905">
<h3 id="_hash_maps">9.2. Hash Maps</h3>
<div class="paragraph data-line-906">
<p>Hash maps are useful to look up data without using idex, but keys. Iterators may also be used to generate keys easily.</p>
</div>
<div class="listingblock data-line-907">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &amp;scores {
        println!("{}: {}", key, value);
    }</code></pre>
</div>
</div>
<div class="sect3 data-line-919">
<h4 id="_updating_a_hash_map">9.2.1. Updating a Hash Map</h4>
<div class="paragraph data-line-920">
<p>Although the number of key-values is growable, each key can ONLY have ONE VALUE associated at any time. You can handle collisions in three ways:</p>
</div>
<table class="tableblock frame-all grid-all stretch data-line-924">
<caption class="title">Table 10. Collision handling in hash maps</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">insert</th>
<th class="tableblock halign-left valign-top">or_insert</th>
<th class="tableblock halign-left valign-top">combination</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">(default) Overwriting value. Using insert().</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Only updating value if key has no value. Using or_insert().</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Updating a value based on Old value. Take the previous value and run an expression/operation using it.</p></td>
</tr>
</tfoot>
</table>
<div class="admonitionblock note data-line-930">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph data-line-931">
<p><strong>Hashing function</strong></p>
</div>
<div class="paragraph data-line-933">
<p>By default, HashMap uses a “cryptographically strong” hashing function called Blake(see Blake (edit: updated to sipHash) <a href="https://www.131002.net/siphash/siphash.pdf" data-href="https://www.131002.net/siphash/siphash.pdf">updated to SipHash</a>. Provides resistance to DoS attacks, but its tradeoff for security drops a little speed. However, it can be changed for a different hasher using BuildHasher trait.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-938">
<h2 id="_error_handling">10. Error Handling</h2>
<div class="sectionbody">
<div class="paragraph data-line-939">
<p>Rust divides errors(Rust doesn’t have exceptions) into 2 categories:</p>
</div>
<div class="ulist data-line-941">
<ul>
<li class="data-line-941">
<p>Recoverable errors: its reasonable to report the problem to the user and retry the operation. it uses <span class="blue">Result&lt;T, E&gt;</span> enum</p>
</li>
<li class="data-line-942">
<p>Unrecoverable errors: symptoms of bugs, like trying to access a location beyond the end of an array. It uses <span class="blue">panic!</span> Macro to print a failure message, unwind and clean up the stack, finally exiting the program.</p>
</li>
</ul>
</div>
<div class="exampleblock data-line-944">
<div class="content">
<div class="paragraph data-line-945">
<p>Errors can be expanded using --explain parameter or  using --verbose.</p>
</div>
</div>
</div>
<div class="sect2 data-line-949">
<h3 id="_unrecoverable_errors_with_panic">10.1. Unrecoverable errors with panic!</h3>
<div class="paragraph data-line-950">
<p>A full <span class="blue">panic!</span> Unwinds and cleans the stack. Alternatively, Rust can just use <span class="blue">abort</span> profile(panic = ‘abort’) which ends the program without cleaning the stack to speed up the process and reduce binary size.</p>
</div>
<div class="paragraph data-line-952">
<p><strong>Backtracing a panic!, and its C counterpart</strong></p>
</div>
<div class="paragraph data-line-954">
<p>Lets use an accessing out-of-bound element.
In C, attempting to read beyond the end of data structure results in <span class="underline">undefined behavior</span>. You might get whatever is at the location in memory(buffer overread which leads to security vulnerabilities),</p>
</div>
<div class="paragraph data-line-957">
<p>In Rust, the execution <span class="underline">panics</span>. The error points at the slice(libcore/slice/mod.rs)  implementation of Rust source code and backtraces from there(shows all the function calls up to that point).</p>
</div>
</div>
<div class="sect2 data-line-959">
<h3 id="_recoverable_errors_with_result">10.2. Recoverable errors with Result</h3>
<div class="paragraph data-line-960">
<p>Most errors aren’t serious enough to require executing exit. For example, trying to open a file is better to recover from it by using <span class="blue">Result&lt;T, E&gt;</span> enum:</p>
</div>
<div class="listingblock data-line-961">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use std::fs::File;
fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) =&gt; file,	//when result is Ok, return the inner file value of the Ok
        Err(error) =&gt; panic!("Problem opening the file: {:?}", error),
    };
}</code></pre>
</div>
</div>
<div class="paragraph data-line-973">
<p><strong>Matching Different Errors</strong></p>
</div>
<div class="paragraph data-line-975">
<p>The previous code panic in <span class="red">any</span> case. However, If we want to instead open a file if the failure reason was due to inexistence of the file and panic in any other case, then we would simply divide the match expression.</p>
</div>
<div class="listingblock data-line-976">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open("hello.txt");

    let f = match f {
        Ok(file) =&gt; file, //when result is Ok, return the inner file value of the Ok
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create("hello.txt") { //inexisting file
                Ok(fc) =&gt; fc, // returns the recently created file
                Err(e) =&gt; panic!("Problem creating the file: {:?}", e),
            },
            other_error =&gt; {
                panic!("Problem opening the file: {:?}", other_error)
            }
        },
    };
}</code></pre>
</div>
</div>
<div class="paragraph data-line-998">
<p>This way we can resolve for any specific or set of errors. Note that an error handler for create new file had to be added as it might also fail. That’s a lot of match!, match is very useful but also very primitive, see closures on <a href="#_functional_features_closures_and_iterators">Functional features: Closures and Iterators</a>. Closures would create something like this:</p>
</div>
<div class="listingblock data-line-999">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">fn main() {
    let f = File::open("hello.txt").unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create("hello.txt").unwrap_or_else(|error| {
                panic!("Problem creating the file: {:?}", error);
            })
        } else {
            panic!("Problem opening the file: {:?}", error);
        }
    });
}</code></pre>
</div>
</div>
<div class="sect3 data-line-1012">
<h4 id="_unwrap_and_expect_shortcuts_for_panic_on_error">10.2.1. ‘unwrap’ and ‘expect’: shortcuts for Panic on Error</h4>
<div class="paragraph data-line-1013">
<p><span class="blue">Unwrap</span> is a shortcut method for match-Result, <span class="underline">returns value inside Ok</span> or <span class="blue">panic!</span> in case Err.
<code>let f = File::open("hello.txt").unwrap();</code></p>
</div>
<div class="paragraph data-line-1016">
<p><span class="blue">expect</span> is similar to unwrap but let us choose the panic! error message.
<code>let f = File::open("hello.txt").expect("Failed to open hello.txt");</code></p>
</div>
<div class="paragraph data-line-1019">
<p><strong>Propagating errors</strong></p>
</div>
<div class="paragraph data-line-1021">
<p>When calls inside a function might fail, you can instead propagate the error to have more control over calling function. This is, return the error to the function whose contents has error prone calls.</p>
</div>
<div class="listingblock data-line-1022">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use std::fs::File;
use std::io;
use std::io::Read;
// function that returns a String inside Ok or err of type ioError
fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; { //propagated error
let f = File::open("hello.txt");

let mut f = match f {
    Ok(file) =&gt; file,
    Err(e) =&gt; return Err(e),};  			//error prone call

let mut s = String::new();
match f.read_to_string(&amp;mut s) {
    Ok(_) =&gt; Ok(s),
    Err(e) =&gt; Err(e),					//error prone call
}
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1043">
<p>There is also a <span class="underline">shortcut for propagating errors</span>: The <span class="blue"><strong> ? </strong></span> operator. ? operator can <span class="red">only be used on functions that return Result enum.</span></p>
</div>
<div class="listingblock data-line-1044">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let mut f = File::open("hello.txt")?;
let mut s = String::new();
f.read_to_string(&amp;mut s)?;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-1050">
<h3 id="_to_panic_or_not_to_panic">10.3. to panic! or not to panic!</h3>
<div class="paragraph data-line-1051">
<p>You can not panic when:</p>
</div>
<div class="ulist data-line-1053">
<ul>
<li class="data-line-1053">
<p>Unwrap and expect are handy when <strong>PROTOTYPING</strong>, they act as placeholder for when you actually decide how to handle the errors in a more robust way. But they are not recommended for releases because they just exit the program.</p>
</li>
<li class="data-line-1054">
<p>When you know result will have an Ok value its fine to use unwrap, basically you have more information than the compiler. For example, hardcoded values.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-1056">
<p>Its advisable to panic! when:</p>
</div>
<div class="ulist data-line-1058">
<ul>
<li class="data-line-1058">
<p>You could end up in a bad state(not expected).</p>
</li>
<li class="data-line-1059">
<p>Input values are not valid and you cannot encode the information provided by other means. However, you can ensure data validity by creating Custom Types : <code>pub struct Guess { value: i32, }</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1062">
<h2 id="_generic_types_traits_and_lifetimes">11. Generic Types, Traits and Lifetimes</h2>
<div class="sectionbody">
<div class="paragraph data-line-1063">
<p>Generics creates a definition of an abstract-generalized behavior for items like function signatures or structs using generic types instead of concrete types to reduce code duplication.</p>
</div>
<div class="paragraph data-line-1065">
<p>Traits define behavioral properties in a generic way. Traits are used with generic types to constraint types.</p>
</div>
<div class="paragraph data-line-1067">
<p>Lifetimes allow us to borrow values, while enabling the compiler to check validity of references.</p>
</div>
<div class="sect2 data-line-1070">
<h3 id="_generic_data_types">11.1. Generic Data Types</h3>
<div class="paragraph data-line-1071">
<p>To define a generic, the type parameter is declared before use it and inside angle brackets &lt;&gt;.</p>
</div>
<div class="listingblock data-line-1072">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">!! fn largest&lt;T&gt;(list: &amp;[T]) -&gt; &amp;T { // finds biggest value inside a list
	let mut largest = &amp;list[0];
    	for item in list {
        		if item &gt; largest {	// Order Error: cannot compare all possible T types
           	 	largest = item;}
	}
	largest
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1083">
<p><span class="red">OrderError</span>: We can only use types whose values can be ordered. And we don’t know if type T is able to do that so we have to assign the ordering property using <strong>traits</strong>.</p>
</div>
<div class="paragraph data-line-1085">
<p><strong>Performance of code using generics</strong></p>
</div>
<div class="paragraph data-line-1087">
<p>Your code doesn’t run any slower using generics than concrete types!. Rust accomplishes generics using monomorphization, that means that generic code is turned into specific code by fillling concrete types at compile time.</p>
</div>
</div>
<div class="sect2 data-line-1090">
<h3 id="_traits_defining_shared_behavior">11.2. Traits: Defining shared behavior</h3>
<div class="paragraph data-line-1091">
<p>Traits are similar to a feature called <strong>Interfaces</strong>. Different types share the same behavior if we can call the same methods/functionalities on all of those types. Trait definitions are a way to group method signatures together to define a set of behaviors.</p>
</div>
<div class="paragraph data-line-1093">
<p><strong>Creating a Trait</strong></p>
</div>
<div class="paragraph data-line-1095">
<p>Example: You have multiple structs that holds various kinds of text instances: NewsArticle, Tweet and metadata(indicates type of tweet: retweet, reply). We want to make a media aggregator that displays all kinds of text. Hence, we need a to request the summary(trait) by calling summarize method on an instance:</p>
</div>
<div class="listingblock data-line-1096">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">pub trait Summary {		//creating the Summary trait, that returns text instances
    fn summarize(&amp;self) -&gt; String;
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1102">
<p>After this summarize method signature, instead of providing an implementation we put a <mark>semicolon</mark>. Each type implementing this trait must <span class="underline">provide its own behavior</span>; the compiler enforces the use of summarize method.</p>
</div>
<div class="paragraph data-line-1104">
<p><strong>Implementing a Trait on a type</strong></p>
</div>
<div class="paragraph data-line-1106">
<p>To apply the Summary trait for the media aggregator, simply put the trait keyword after impl and use “<span class="blue"><strong>for</strong></span>” to specify the name of the type we want to implement the trait for.</p>
</div>
<div class="listingblock data-line-1108">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">//lib.rs
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {		// Summary trait for article

    fn summarize (&amp;self) -&gt; String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}
pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {		// Summary trait for tweet
    fn summarize(&amp;self) -&gt; String {
        format!("{}: {}", self.username, self.content)
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning data-line-1137">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph data-line-1138">
<p>One restriction to note with trait implementations is that we can implement a trait on a type <span class="red">only if either the trait or the type is local to our crate, so we know which implementation use</span>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-1142">
<p><strong>Default implementations and override</strong></p>
</div>
<div class="paragraph data-line-1144">
<p>Override is achieved through traits, we can define a default implementation in a trait using brackets “{}” instead of semicolon, and then let the type override or maintain the default behavior.</p>
</div>
<div class="paragraph data-line-1146">
<p>Default implementations can call other methods in the same trait because they are guaranteed to be defined.</p>
</div>
<div class="listingblock data-line-1147">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from("(Read more...)")	//Default implementation
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1156">
<h3 id="_traits_as_parameters">11.3. Traits as parameters</h3>
<div class="paragraph data-line-1158">
<p>Allow us to define the behavior of a parameter in a function, this will guarantee that a parameter behaves(implements a trait) a certain way so we can call certaing functions on it. Simply add <span class="blue">impl</span> keyword to the parameter:</p>
</div>
<div class="listingblock data-line-1159">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">pub fn notify(item: &amp;impl Summary) {		//item must be able to make summaries
    println!("Breaking news! {}", item.summarize());
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1165">
<p>Or using generics:</p>
</div>
<div class="listingblock data-line-1166">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) { 	//item T type must implement summary and display
    println!("Breaking news! {}", item.summarize());
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1172">
<p>Multiple traits can be aggregated used + operator. But if there are many involved, the + makes it unreadable. Clauses(bounds) specify a <span class="underline">set of Traits</span> with <span class="blue">where</span> keyword.</p>
</div>
<div class="listingblock data-line-1173">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">pub fn notify&lt;T, U&gt;(item: &amp;T, other: &amp;U) -&gt; i32
    where T: Summary + Display,
      U: Clone + Debug
{</code></pre>
</div>
</div>
<div class="paragraph data-line-1181">
<p><strong>Fixing Generic “largest” function with Traits</strong></p>
</div>
<div class="paragraph data-line-1183">
<p>Using traits, we ca ensure that items are comparable by making the generic types implement the <span class="red">PartialOrd</span> trait and items should be able to be copied(only stack located) so generic type should also implement <span class="red">Copy</span> trait.</p>
</div>
<div class="listingblock data-line-1184">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0]; 		//Copy: should be able to copy/index data

    for &amp;item in list {
        if item &gt; largest {		//PartialOrd: can compare values
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!("The largest number is {}", result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!("The largest char is {}", result);
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1209">
<p>Traits can also be used to condition the implementation of method. For example, struct Pair only implements cmp_Display method if the inner type T implements PartialOrd and Display traits:</p>
</div>
<div class="listingblock data-line-1210">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {			//always implemented
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {			//only implemented if T implements Display and PartialOrd
        if self.x &gt;= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1236">
<h3 id="_validating_references_with_lifetimes">11.4. Validating references with Lifetimes</h3>
<div class="paragraph data-line-1237">
<p>Every reference has a lifetime, which is the scope for which that reference is valid. Most of times, lifetimes are implicit and inferred just like types. However, sometimes, when multiple lifetimes lifespans are possible we must annotate lifetimes also like types.</p>
</div>
<div class="paragraph data-line-1239">
<p>Lifetimes annotations come handy to bound multiple variables to the same lifetime.</p>
</div>
<div class="paragraph data-line-1241">
<p><strong>Borrow checker</strong></p>
</div>
<div class="paragraph data-line-1243">
<p>Compares the scopes of the variables to determine whether all borrows are valid. Here we can see r with a lifetime ‘a and x with a lifetime ‘b. The borrow checker determines that the lifetime of x is shorter so there is a dangling reference.</p>
</div>
<div class="listingblock data-line-1244">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">!!{// This code doesn’t compile because lifetime “'b” bound to variable x is no longer valid when printing r.
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!("r: {}", r); //          | 	//x is not valid
    }                         // ---------+</code></pre>
</div>
</div>
<div class="paragraph data-line-1256">
<p><strong>Generic lifetimes annotation</strong></p>
</div>
<div class="paragraph data-line-1258">
<p>When compiler can’t tell the lifetime inside a function, for example if 2 possible lifetimes are available(if-else could be one case). A lifetime annotation must be provided, <span class="underline">describing the relationships of the lifetimes of multiple references to each other</span>.</p>
</div>
<div class="paragraph data-line-1260">
<p>The syntax uses an apostrophe (‘) and it<strong> describes relationships of the lifetimes of multiple references to each other</strong>. For example, a function parameter with lifetime ‘a is applied to all parameters meaning that <span class="underline">all the references in the parameters and the return value must live as long as the generic lifetime.</span></p>
</div>
<div class="listingblock data-line-1261">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1270">
<h3 id="_predictable_lifetime_by_elision_rules">11.5. Predictable Lifetime by elision rules</h3>
<div class="paragraph data-line-1272">
<p><span class="red">Every reference needs a lifetime</span> and you need to specify lifetime parameters for functions or structs that use references. However, because certain reference-lifetime patterns are predictable, Rust programmers programmed patterns into Rust borrow checker called lifetime elision rules, they are a set of cases where the compiler can infer the lifetime of the reference.
The elision rules are:</p>
</div>
<div class="olist arabic data-line-1275">
<ol class="arabic">
<li class="data-line-1275">
<p><strong>Each parameter</strong> that is a reference gets its <strong>own lifetime</strong> parameter. In other words, a function with one parameter gets one lifetime parameter: fn foo&lt;'a&gt;(x: &amp;'a i32); a function with two parameters gets two separate lifetime parameters: fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32); and so on.</p>
</li>
<li class="data-line-1276">
<p>If there is exactly <span class="underline">one input lifetime parameter</span>, that lifetime is assigned to <span class="underline">all output lifetime parameters</span>: fn foo&lt;'a&gt;(x: &amp;'a i32) &#8594; &amp;'a i32.</p>
</li>
<li class="data-line-1277">
<p>if there are <strong>multiple input lifetime parameters</strong>, but one of them is &amp;self or &amp;mut self because this is a method, the lifetime of <strong>self is assigned to all output</strong> lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-1279">
<p><strong>The static lifetime</strong></p>
</div>
<div class="paragraph data-line-1281">
<p>‘static is a reference that can live for the entire duration of the program.</p>
</div>
<div class="paragraph data-line-1283">
<p><strong>Generic Types, Traits and Lifetimes together</strong></p>
</div>
<div class="paragraph data-line-1285">
<p>This program returns the longer of two string slices(Lifetimes) but also prints an announcement of type T(Traits and generics)</p>
</div>
<div class="listingblock data-line-1286">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;( x: &amp;'a str,  y: &amp;'a str,  ann: T) -&gt; &amp;'a str
    where
    T: Display,
{
    println!("Announcement! {}", ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1302">
<h2 id="_writing_automated_test">12. Writing automated test</h2>
<div class="sectionbody">
<div class="sect2 data-line-1303">
<h3 id="_how_to_write_tests">12.1. How to write tests</h3>
<div class="paragraph data-line-1304">
<p>Test functions typically perform 3 actions:</p>
</div>
<div class="ulist data-line-1306">
<ul>
<li class="data-line-1306">
<p>Set up any needed data or state.</p>
</li>
<li class="data-line-1307">
<p>Run the code you want to test.</p>
</li>
<li class="data-line-1308">
<p>Assert the results are what you expect.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-1310">
<p>Rust offers <span class="blue">test</span> and <span class="blue">should_panic</span> attributes and macros to achieve these actions.</p>
</div>
<div class="paragraph data-line-1312">
<p><strong>Creating test functions</strong></p>
</div>
<div class="paragraph data-line-1314">
<p>To change a function into a test function, add <span class="blue">#[test]</span> before fn. Test can be run with “cargo test” command for which Rust builds a test runner <strong>special binary</strong> that contains and reports only the test annotated functions.</p>
</div>
<div class="paragraph data-line-1316">
<p><code>cargo new library_name –lib</code> &#8594; Creates a new library for test function</p>
</div>
<div class="paragraph data-line-1319">
<p><code>cargo test</code> &#8594; runs test library.</p>
</div>
<div class="listingblock data-line-1320">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">// src/lib.rs
#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch data-line-1333">
<caption class="title">Table 11. Test functions</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assert_eq!(a,b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes test only if a == b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">assert_ne!(a,b)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes test only if a != b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assert!(a)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Passes only if a == true</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Use super::*;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Brings anything written in the outer scope to the test module, to be able to use any declared function of src.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">#[test]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Converts a function into a test function</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">#[cfg(test)]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Tells Rust to compile the module only when cargo test command is run.</p></td>
</tr>
</tfoot>
</table>
</div>
<div class="sect2 data-line-1344">
<h3 id="_controlling_how_test_are_run">12.2. Controlling how test are run</h3>
<div class="paragraph data-line-1345">
<p>You can select a single test to run or select multiple by pattern matching.</p>
</div>
<table class="tableblock frame-all grid-all stretch data-line-1349">
<caption class="title">Table 12. Test flow</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Function</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo test<br>
--test-threads = 1<br>
--show-output</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Defualt behavior of cargo test is to run all test In parallel, but this can be change by:<br>
--test-threads = 1 runs the test in the specified number of threads.<br>
&#8201;&#8212;&#8201;show output, prints all values that where run in the test</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cargo test {function}</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Runs single test or patterns that mathc the function names</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">#[ignore]
cargo test&#8201;&#8212;&#8201;--ignored</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ignore specific test that are for example very time-consuming.
runs only ignored test</p></td>
</tr>
</tfoot>
</table>
</div>
<div class="sect2 data-line-1366">
<h3 id="_test_organization">12.3. Test organization</h3>
<div class="sect3 data-line-1367">
<h4 id="_unit_tests">12.3.1. Unit tests</h4>
<div class="paragraph data-line-1368">
<p>Built within the module, test each unit of code in isolation. &#8594; The convention is to create a module named <span class="green"><strong>test INSIDE THE module.rs file!</strong></span> and annotate it with cfg(test) in each file that contain test functions.</p>
</div>
<div class="paragraph data-line-1370">
<p><strong>This saves compile time</strong> when you only want to build the library and <strong>saves space</strong> in the resulting compiled artifact because the tests are not included in the binary.</p>
</div>
<div class="listingblock data-line-1372">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">// module.rs
fn run(){…}	//even if this is private can be tested
…
#[cfg(test)]
mod test {
    use super::*;	//includes even private function

    #[test]
    fn test_run() {…}</code></pre>
</div>
</div>
<div class="paragraph data-line-1383">
<p>Unit tests include even private functions.</p>
</div>
</div>
<div class="sect3 data-line-1385">
<h4 id="_integration_tests">12.3.2. Integration tests</h4>
<div class="paragraph data-line-1386">
<p>Integration tests are entirely external to your library. Only calls functions that are part of the <span class="green">public API</span>. They test coherency between parts of the library. &#8594; The convention is to create a tests directory at the top level of the project, next to src. Thes only require <span class="blue">#[test]</span>.</p>
</div>
<div class="listingblock data-line-1387">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">//tests/integration_test.rs
use adder;	//we need use keyword because “tests” is a separate crate so we need to bring adder into scope

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1397">
<h2 id="_functional_features_closures_and_iterators">13. Functional features: Closures and Iterators</h2>
<div class="sectionbody">
<div class="paragraph data-line-1398">
<p>We’ll cover:</p>
</div>
<div class="ulist data-line-1400">
<ul>
<li class="data-line-1400">
<p>Closures: a function-like construct you can store in a variable</p>
</li>
<li class="data-line-1401">
<p>Iterators: a way of processing a series of elements</p>
</li>
<li class="data-line-1402">
<p>How to use these two features to improve the minigrep project</p>
</li>
<li class="data-line-1403">
<p>The performance of these two features (Spoiler alert: they’re faster than you might think!)</p>
</li>
</ul>
</div>
<div class="sect2 data-line-1405">
<h3 id="_closures">13.1. Closures</h3>
<div class="paragraph data-line-1406">
<p>Closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and call it in a different context. Unlike functions, closures can capture values from the scope in which they are defined.</p>
</div>
<div class="sect3 data-line-1408">
<h4 id="_closures_vs_functions">13.1.1. Closures vs functions</h4>
<div class="paragraph data-line-1409">
<p>Consider we want to Implement the following behavior: we have an expensive algorithm that we want to call it <span class="underline">only once</span> or the least ammount of times because it consumes a lot of resources. We would call it only when we get new data. The expensive algorithm can be implemented as:</p>
</div>
<div class="paragraph data-line-1411">
<p><strong>Functions</strong></p>
</div>
<div class="paragraph data-line-1413">
<p>Implementing the expensive calculation as a function as shown below, <span class="red">executes whenever we need the result</span> of the calculation, so that isn’t of much help because if we call it multiple times (<span class="red">even with the same parameter</span>) would slow our program.</p>
</div>
<div class="listingblock data-line-1415">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    println!("expensive calculation...");
    thread::sleep(Duration::from_secs(3));
    intensity
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1425">
<p><strong>Creating and storing a closure</strong></p>
</div>
<div class="paragraph data-line-1427">
<p>Instead of always calling the function, we can define a closure and store it in a variable as follows:</p>
</div>
<div class="listingblock data-line-1429">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use std::thread;
use std::time::Duration;
//closures start with a pair of vertical pipes ”|”, inside which we specify the parameters of the closure.
//let contains the DEFINITION of an anonymous function, not the result
let expensive_closure = |num| {
        println!("expensive calculation...");
        thread::sleep(Duration::from_secs(2));
        num
    };
println!("Calling the closure", expensive_closure(43));
//at this point we still need to execute the expensive_closure each time we need the result but we will see on "Cache:Storing closures" how to implement memory to remember past calculations</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-1444">
<h3 id="_closure_features">13.2. Closure features</h3>
<div class="ulist data-line-1445">
<ul>
<li class="data-line-1445">
<p>Closures allow us to <span class="blue">define the code</span> to call at one point, store it in a variable and call it at a later point.</p>
</li>
<li class="data-line-1446">
<p>Closures do not require explicit annotations of types because they are not part of the user interface which requires explicit annotations to ensure everyone agrees on what types of values functions uses.</p>
</li>
<li class="data-line-1447">
<p>Closures are usually short and relevant only within a narrow context/scope so compiler is reliably able to infer parameters and return types.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-1449">
<p><strong>Where does the closure syntax comes from?</strong></p>
</div>
<div class="paragraph data-line-1451">
<p>Functional language use pipes, and closures syntax also derives from a function without annoying annotations. However, closures can be as annotated as functions as shown in add_one_v2 closure.</p>
</div>
<div class="listingblock data-line-1453">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1460">
<h3 id="_cache_storing_closures_using_generic_parameters_and_traits">13.3. Cache: Storing closures using generic parameters and traits</h3>
<div class="paragraph data-line-1461">
<p>Structs can hold closures and store results of calls to the closure. Then we can use a <span class="green"><strong>Struct as a cache</strong></span> to reduce the number of expensive_calculation executions by only executing the closure if we havent compute the result before.</p>
</div>
<div class="paragraph data-line-1463">
<p>To define Structs, we need to specify the <span class="red">type</span> of the closure, because a <span class="red">struct definition needs to know the types of each of its fields in compile time</span>. Each closure instance has a unique type signature; Structs, enums or function parameters that use closures need to use generics and trait bounds. Fn trait is provided by the standard library, Fn represent the types of parameter and return values that the closures must have to match this trait.</p>
</div>
<div class="listingblock data-line-1464">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">// Private struct implementing closure with parameter and return type u32.
// This is private because we want cacher to manage the struct field rather than code.
#[derive(Debug)]
struct Cacher&lt;T&gt;
where T: Fn(u32) -&gt; u32,		//each closure instance has a unique type signature
{
    calculation: T,
    cache: HashMap&lt;u32, u32&gt;,
}
impl&lt;T&gt; Cacher &lt;T&gt;
where T: Fn(u32) -&gt; u32,
{
//Cacher::new returns a Cacher instance that holds calculation-closure
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            cache: HashMap::new(),
        }
    }
//we call value, whenever we need a result of expensive calculation-closure, it will store if is not in the memory or re-trieve the value if it was calculated before.
    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        let previously_calculated= self.cache.entry(arg);
        match previously_calculated {
            Entry::Occupied(v) =&gt; *v.get(), //retrieve previous value and skip expensive_calculation
            _ =&gt;{
                let value = (self.calculation)(arg);        //call expensive_closure
                self.cache.insert(arg, value);              //insert new entry
                value }}}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1494">
<h3 id="_capturing_environment_with_closures">13.4. Capturing environment with closures</h3>
<div class="paragraph data-line-1495">
<p>Closures can capture environment and access variables from the SCOPE WHERE THEY WHERE DEFINED.</p>
</div>
<div class="listingblock data-line-1496">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let x = 4;
// even though “x” is not a parameter of equal_to_x closure, the closure is allowed to use x variable because its in
//   the same scope.
let equal_to_x = |parameter| {	//closure definition
parameter== x
};

let y = 4;

assert!(equal_to_x(y));		//closure call, assert passes!.  x is equal to y</code></pre>
</div>
</div>
<div class="paragraph data-line-1509">
<p>Closures can capture values from the environment in three ways:</p>
</div>
<div class="ulist data-line-1511">
<ul>
<li class="data-line-1511">
<p>FnOnce, consumes the variables it captures from its enclosing scope, known as the closure’s environment. To consume the captured variables, the closure must take ownership of these variables and move them into the closure when it is defined. The Once part of the name represents the fact that the closure can’t take ownership of the same variables more than once, so it can be called only once.
You can use <span class="blue">move</span> keyword to take ownership.</p>
</li>
<li class="data-line-1513">
<p>FnMut, can change the environment because it mutably sborrows values.</p>
</li>
<li class="data-line-1514">
<p>Fn, borrows values from the environment immutably.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-1516">
<p>However, when closures capture the environment, it uses memory to store the values for the use in the closure body. This use of memory is <span class="red">overhead</span> that we don’t want to pay in more common cases.</p>
</div>
</div>
<div class="sect2 data-line-1518">
<h3 id="_iterators">13.5. Iterators</h3>
<div class="paragraph data-line-1519">
<p>An iterator is responsible of the logic for traverse over each item and determining when the sequence has finished.</p>
</div>
<div class="sect3 data-line-1521">
<h4 id="_features">13.5.1. Features</h4>
<div class="ulist data-line-1522">
<ul>
<li class="data-line-1522">
<p>Iterators are “lazy”: meaning they have no effect until you call methods that perform an operation.</p>
</li>
<li class="data-line-1523">
<p>Zero-cost abstractions: Iterators apply different kinds <span class="blue">algorithms</span> to different kinds of <span class="blue">sequences</span>, so they <span class="green">normally improve performance.</span></p>
</li>
<li class="data-line-1524">
<p>Interface maintained: algorithms are apply by the compiler, so the <span class="green">user interface is maintained</span> over these different sequences.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-1526">
<h4 id="_consumer_adaptors_and_iterator_adaptors">13.5.2. Consumer Adaptors and iterator adaptors</h4>
<div class="paragraph data-line-1527">
<p>All iterators implement Iterator trait. Next method consumes the iterated item, this means that once called next() the item will no longer be usable because it loses ownership.</p>
</div>
<div class="listingblock data-line-1528">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">pub trait Iterator {
    type Item;	//associated type chapter 19(Advanced features)

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;; //returns either an Item or None

// methods with default implementations. This means only next() requires implement-ing.
}
let v1 = vec![1];
//mutable because each call eats/consumes up an item.
let mut v1_iter = v1.iter();

assert_eq!(v1_iter.next(), Some(&amp;1));	//returns an immutable reference
assert_eq!(v1_iter.next(), None);		//there is just one element
//v1_iter is no longer usable because it was consumed by next(), other methods that use //next() are called “consumer adaptors” because they also consume items via next()</code></pre>
</div>
</div>
<div class="paragraph data-line-1545">
<p>similarly into_iter() returns owned values and iter_mut() returns mutable references.
“<strong>Iterator adaptors</strong>” change iterators into another kind of iterator(normally more complex), for example a map. <span class="red">But they need to be called by a consumer adaptor to obtain a result because of iterators lazyness.</span></p>
</div>
<div class="listingblock data-line-1547">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-1556">
<h4 id="_filtering_iterators_with_closures">13.5.3. Filtering Iterators with closures</h4>
<div class="paragraph data-line-1557">
<p>The <span class="blue">filter</span> method takes a closure that takes each item of the iterator and returns a Boolean, If the closure returns true, the value is included in the iterator produced by filter otherwhise is excluded.
Example: filtering shoe size: This function retrieves only shoes of a specific size.</p>
</div>
<div class="listingblock data-line-1559">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter().filter(|s| s.size == shoe_size).collect() //yellow is the closure.
}</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-1571">
<h4 id="_creating_our_own_iterators_with_iterator_trait">13.5.4. Creating our own Iterators with Iterator trait</h4>
<div class="paragraph data-line-1572">
<p>As mentioned before, when creating custom iterators, <span class="blue">the only method you are required to provide definition is next()</span>. Ex: Implementing Iterator for a counter struct that counts up to 5, above 5 returns None:</p>
</div>
<div class="listingblock data-line-1573">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}

impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.count &lt; 5 {
            self.count += 1;
            Some(self.count)
        } else {
            None
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-1598">
<h4 id="_comparing_performance_loops_vs_iterators">13.5.5. Comparing Performance: Loops vs Iterators</h4>
<div class="paragraph data-line-1599">
<p>Rust developers compared loop vs Iterators on IO Projects and the results are as follows:</p>
</div>
<div class="listingblock data-line-1600">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)	//loop
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)	//iterators</code></pre>
</div>
</div>
<div class="paragraph data-line-1604">
<p>Iterators are slightly faster. Iterators get compiled to roughly same code as if you’d written the lower-level code yourself. <span class="green">Iterators are one of the Rusts ZERO-COST-ABSTRACTIONS</span>, making code look like high level but it gets compiled to optimzed instructions. An example of rust optimization is loop unrolling.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1607">
<h2 id="_more_about_cargo_and_crates_io">14. More about Cargo and Crates.io</h2>
<div class="sectionbody">
<div class="paragraph data-line-1608">
<p>Cargo can do much mora than build, run and test code. You can find everything cargo can do on Cargo book:  <a href="https://doc.rust-lang.org/cargo/index.html" class="undefined" data-href="https://doc.rust-lang.org/cargo/index.html">https://doc.rust-lang.org/cargo/index.html</a></p>
</div>
<div class="ulist data-line-1610">
<ul>
<li class="data-line-1610">
<p>Customize your build through release profiles</p>
</li>
<li class="data-line-1611">
<p>Publish libraries on crates.io</p>
</li>
<li class="data-line-1612">
<p>Organize large projects with workspaces</p>
</li>
<li class="data-line-1613">
<p>Install binaries from crates.io</p>
</li>
<li class="data-line-1614">
<p>Extend Cargo using custom commands</p>
</li>
</ul>
</div>
<div class="sect2 data-line-1616">
<h3 id="_customizing_builds_with_release_profiles">14.1. Customizing builds with release profiles</h3>
<div class="paragraph data-line-1617">
<p>You can add custom profiles on Cargo.toml, by adding [profile.*] sections to any profile you want to cutomize.</p>
</div>
<div class="listingblock data-line-1618">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">//Cargo.toml
[profile.dev]
opt-level = 0
//Look on https://doc.rust-lang.org/cargo/reference/profiles.html for the complete list of configuration options.
[profile.release]
opt-level = 3		//maximum level of optimization</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1627">
<h3 id="_documenting_and_publishing_a_crate_to_crates_io">14.2. Documenting and publishing a Crate to Crates.io</h3>
<div class="paragraph data-line-1628">
<p>Documentation comments use three slashes “///” for documenting function and support Markdown notation. Finally you can generate the HTML documentation from documentation comments using cargo doc. Also “//!” add docomentation to the crate itself.</p>
</div>
<div class="paragraph data-line-1630">
<p>Documentation code, between triple backticks (` ` `) can run with cargo test.</p>
</div>
</div>
<div class="sect2 data-line-1632">
<h3 id="_cargo_workspaces">14.3. Cargo workspaces</h3>
<div class="paragraph data-line-1633">
<p>Help manage multiple related packages that are developed in tandem.</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1635">
<h2 id="_smart_pointers">15. Smart Pointers</h2>
<div class="sectionbody">
<div class="paragraph data-line-1636">
<p><span class="blue">A pointer</span> is a general concept for a <span class="blue">variable that contains an address in memory</span>. This address refers to, or “points at,” some other data. The most common kind of pointer in Rust is a reference(&amp;), which only borrows data. <span class="green">They don’t have any special capability nor overhead.</span></p>
</div>
<div class="paragraph data-line-1638">
<p><span class="blue">Smart pointers</span>, on the other hand, are <span class="blue">data structures</span> that not only act like a pointer but also:</p>
</div>
<div class="ulist data-line-1640">
<ul>
<li class="data-line-1640">
<p>Have additional capabilities(some smart pointers own data or make some guarantee) and metadata.</p>
</li>
<li class="data-line-1641">
<p>Usually implemented with structs that implement <span class="blue">Deref</span> (reference like behavior) and <span class="blue">Drop</span> (scope) traits.</p>
</li>
<li class="data-line-1642">
<p>Most common smart pointers are:</p>
<div class="ulist data-line-1643">
<ul>
<li class="data-line-1643">
<p><span class="red">Box&lt;T&gt;</span>, for allocating values on the heap</p>
</li>
<li class="data-line-1644">
<p><span class="red">Rc&lt;T&gt;</span>, a reference counting type that enables multiple ownership of data by keeping track of the number of owners and cleans up when no owner remains.</p>
</li>
<li class="data-line-1645">
<p><span class="red">Ref&lt;T&gt;</span> and RefMut&lt;T&gt;, accessed through RefCell&lt;T&gt;, a type that enforces the borrowing rules at runtime instead of compile time. Allow us to mutate data of immutable references.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph data-line-1647">
<p>We’ve already encountered a few smart pointers, such as String and Vec&lt;T&gt; in Chapter 8, Both these types count as smart pointers because they own some memory and allow you to manipulate it. They also have metadata (such as their capacity) and extra capabilities or guarantees (such as with String ensuring its data will always be valid UTF-8).</p>
</div>
<div class="sect2 data-line-1649">
<h3 id="_using_boxt_to_point_to_data_on_the_heap">15.1. Using Box&lt;T&gt; to Point to Data on the Heap</h3>
<div class="paragraph data-line-1650">
<p>Boxes allow you to store data on the heap. They don’t have performance overhead(other than using the heap). They are used in the following situations:</p>
</div>
<div class="ulist data-line-1652">
<ul>
<li class="data-line-1652">
<p>Type whose size can’t be known at compile time and you want to use the exact size.</p>
</li>
<li class="data-line-1653">
<p>Large amount of data and you want to transfer ownership but not copy of data.</p>
</li>
<li class="data-line-1654">
<p>You want to own a value and care only that it’s a type that inplements a particular trait.</p>
</li>
</ul>
</div>
<div class="listingblock data-line-1655">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let b = Box::new(5);			//Creates a box pointer that points to value 5 stored on heap.
println!("b = {}", b);		//When b goes out of scope, also the data in the heap.</code></pre>
</div>
</div>
<div class="paragraph data-line-1659">
<p><strong>Enabling recursive types with boxes</strong></p>
</div>
<div class="paragraph data-line-1661">
<p>At compile time, Rust needs to know how much space a type takes up. However, recursive types like the Cons list(constructs a new pair from 2 arguments) cant be known since the compiler searches for the size of each type so when it checks Cons it has ANOTHER CONS which results in infinite space allocation.</p>
</div>
<div class="imageblock data-line-1664">
<div class="content">
<img src="images/images/4_cons.jpg" alt="4 cons">
</div>
<div class="title">Figure 4. cons</div>
</div>
<div class="listingblock data-line-1667">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}
let cons_list = Cons(1, Cons(2, Cons(3, Nil)));</code></pre>
</div>
</div>
<div class="paragraph data-line-1674">
<p>We use Box to store the value indirectly, this means to store the pointer to the value instead and because it’s a pointer, size is known at compile time.</p>
</div>
<div class="imageblock data-line-1677">
<div class="content">
<img src="images/images/5_box.jpg" alt="5 box">
</div>
<div class="title">Figure 5. cons + box</div>
</div>
<div class="listingblock data-line-1679">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let cons_list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1683">
<h3 id="_implementing_dereference_trait">15.2. Implementing Dereference trait</h3>
<div class="paragraph data-line-1684">
<p>Allows us to <span class="blue">customize the behavior of dereference operator</span>. We will create our own smart pointer that performs similar functions to Box&lt;T&gt;(except for the heap storing).</p>
</div>
<div class="listingblock data-line-1685">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use std::ops::Deref;
impl&lt;T&gt; Deref for MyBox&lt;T&gt; {		//We implement Deref trait
    type Target = T;
//deref borrows self and returns a reference to the inner data(field 0(only one) in the //touple)
    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}
struct MyBox&lt;T&gt;(T);		//MyBox type is a tuple with one element of type T

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)			//returns a MyBox that hold the value passed.
    }
}</code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch data-line-1705">
<caption class="title">Table 13. Regular refernce vs cutom MyBox</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Regular reference</th>
<th class="tableblock halign-left valign-top">Using custom MyBox&lt;T&gt;</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">let x = 5;<br>
let y = &amp;x;<br>
assert_eq!(5, x);<br>
assert_eq!(5, *y);</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">let x = 5;<br>
let y = MyBox::new(x);<br>
assert_eq!(5, x);<br>
assert_eq!(5, *y);</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph data-line-1717">
<p>Types that implement Deref, can implicitly make the dereference operation called Deref coercion. For example String into &amp;str is posible because String implements Deref.</p>
</div>
</div>
<div class="sect2 data-line-1719">
<h3 id="_drop_trait">15.3. Drop Trait</h3>
<div class="paragraph data-line-1720">
<p>The drop trait is in the prelude, Rust runs a specified code whenever a value goes out of scope, so that you don’t need to explicitly deallocate or free memory.</p>
</div>
<div class="listingblock data-line-1721">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1743">
<h3 id="_rct_the_reference_counted_smart_pointer">15.4. RC&lt;T&gt; the reference counted smart pointer</h3>
<div class="paragraph data-line-1744">
<p>When we want a single value to have multiple owners, Rust has a type called Rc&lt;T&gt; which is an abbreviation for reference counting. For example in a graph, where multiple edges point to the same node, that node is conceptually owned by all edges.  We can use Rc&lt;T&gt; for:</p>
</div>
<div class="ulist data-line-1746">
<ul>
<li class="data-line-1746">
<p>Share data via immutable references(for reading only). If you want to mutate data, you can see RefCell&lt;T&gt;(next section).</p>
</li>
<li class="data-line-1747">
<p>Cleanup data only when pointer has 0 owners</p>
</li>
</ul>
</div>
<div class="paragraph data-line-1749">
<p>Imagine you want to point a as follows:</p>
</div>
<div class="imageblock data-line-1751">
<div class="content">
<img src="images/images/6_rc.jpg" alt="6 rc">
</div>
</div>
<div class="paragraph data-line-1753">
<p>Since Cons variants <mark>owns</mark> the data, sharing “a” with “b” would result in a compiler error. Instead, when we create b, we can clone the Rc&lt;List&gt; that “a” is holding(thereby increasing the number of reference of the Rc).</p>
</div>
<div class="listingblock data-line-1754">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));				// increases the counter of owners
    let c = Cons(4, Rc::clone(&amp;a));</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1769">
<h3 id="_refcellt_interior_mutability_pattern">15.5. RefCell&lt;T&gt; interior mutability pattern</h3>
<div class="paragraph data-line-1770">
<p>Interior mutability is a design pattern in Rust that allows you to <span class="underline">mutate data even when there are immutable references to that data</span>. To mutate data, the pattern uses unsafe code inside a data structure, to bend Rusts usual rules that govern mutation and borrowing.</p>
</div>
<div class="paragraph data-line-1772">
<p>With ReffCell&lt;T&gt; borrowing rules are enforced at <strong>runtime(panics and exits like C)</strong>. The advantage of this is that certain memory-safe scenarios are allowed(which normally are disallowed by compile-time checks). For example, allow a value to mutate itself in its methods but appear immutable to other code.</p>
</div>
<div class="paragraph data-line-1774">
<p>Rc&lt;T&gt; and RefCell&lt;T&gt; are <span class="red">only for use in single-threaded scenarios.</span></p>
</div>
<div class="paragraph data-line-1776">
<p><strong>Mock Objects: a use case for interior mutability</strong></p>
</div>
<div class="paragraph data-line-1778">
<p>In this example we create a library that tracks a value against a maximum value and sends messages based on how close to the maximum value the current value is. This could be used to keep track of user quota.</p>
</div>
<div class="paragraph data-line-1780">
<p>A test double is the general programming concept for a type used in place of another type during testing. Mock objects are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place.</p>
</div>
<div class="paragraph data-line-1782">
<p>Rust doesn’t have objects in the same sense as other languages have objects, and Rust doesn’t have mock object functionality built into the standard library as some other languages do. However, you can definitely create a struct that will serve the same purposes as a mock object.</p>
</div>
<div class="listingblock data-line-1783">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
where
    T: Messenger,
{
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send("Error: You are over your quota!");
        } else if percentage_of_max &gt;= 0.9 {
            self.messenger
                .send("Urgent warning: You've used up over 90% of your quota!");
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger
                .send("Warning: You've used up over 75% of your quota!");
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1824">
<p><span class="blue">Messanger</span> trait has a method called <span class="blue">send</span>, which takes an <span class="red">immutable</span> reference to self and the text message. This trait is the interface our mock objects needs to implement, so our Mock object will look as follows:</p>
</div>
<div class="listingblock data-line-1825">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;, 	//sent messages is a RefCell to use interior mutability
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger {
                sent_messages: RefCell::new(vec![]),
            }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--

        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1857">
<p>Rc and RefCell can be combined to create multiple owners of mutable data. However, this can create memory leaks.</p>
</div>
</div>
<div class="sect2 data-line-1859">
<h3 id="_memory_leaks">15.6. Memory leaks</h3>
<div class="paragraph data-line-1860">
<p>Rust doesn’t not guarantee memory safety, althought its difficult. Memory leaks due to reference of items that refer to each other in a cycle are possible because the reference count will never reach 0.</p>
</div>
<div class="paragraph data-line-1862">
<p>To prevent this Rust uses Rc::downgrade which retrieves a Weak&lt;T&gt; smart pointer that basically says that we don’t own the item. Instead of strong_count weak_count is increased but item is not cleanup when reaches 0.</p>
</div>
<div class="listingblock data-line-1863">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">Creating a Tree Data structure
use std::cell::RefCell;
use std::rc::Rc;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;, 		//a child doesn’t own a parent so we use weak RefCell.
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,	//a Node own(and drops) its children and share ownership(Rc).
					//also we want to modify children(RefCell)
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1877">
<p>Leaf and branch operations are as follows:</p>
</div>
<div class="listingblock data-line-1879">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),	//we can get from branch to leaf through branch.children
    });
*leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);	//update the parent of leaf node</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-1894">
<h2 id="_fearless_concurrencyand_or_parallel">16. Fearless Concurrency(and or parallel)</h2>
<div class="sectionbody">
<div class="paragraph data-line-1895">
<p>Concurrent programming, where different parts of a program execute independently, and</p>
</div>
<div class="paragraph data-line-1897">
<p>Parallel programming, where different parts of a program execute at the same time are becoming important.</p>
</div>
<div class="paragraph data-line-1899">
<p>Ownership and type systems are a powerful set of tools to manage memory safety and concurrency problems.</p>
</div>
<div class="paragraph data-line-1901">
<p>Here are the topics we’ll cover in this chapter:</p>
</div>
<div class="ulist data-line-1903">
<ul>
<li class="data-line-1903">
<p>How to create threads to run multiple pieces of code at the same time</p>
</li>
<li class="data-line-1904">
<p>Message-passing concurrency, where channels send messages between threads</p>
</li>
<li class="data-line-1905">
<p>Shared-state concurrency, where multiple threads have access to some piece of data</p>
</li>
<li class="data-line-1906">
<p>The Sync and Send traits, which extend Rust’s concurrency guarantees to user-defined types as well as types provided by the standard library</p>
</li>
</ul>
</div>
<div class="sect2 data-line-1908">
<h3 id="_using_threads_to_run_code_simultaneously">16.1. Using threads to run code simultaneously</h3>
<div class="paragraph data-line-1909">
<p>In most current OS, a program code run in a process and the OS manages multiple processes at once. Within your program you can also have independent parts that run simultaneously(threads&#8594;program flow). However, since threads run simultaneously, they can led to problems such as:</p>
</div>
<div class="ulist data-line-1911">
<ul>
<li class="data-line-1911">
<p>Race conditions, where threads are accessing data or resources in an inconsistent order</p>
</li>
<li class="data-line-1912">
<p>Deadlocks, where two threads are waiting for each other to finish using a resource the other thread has, preventing both threads from continuing</p>
</li>
<li class="data-line-1913">
<p>Bugs, that happen only in certain situations and are hard to reproduce and fix reliably</p>
</li>
</ul>
</div>
<div class="paragraph data-line-1915">
<p>Programming in a multithreaded context requires careful thought and different code structure than the one for single thread.  Programming languages implement threads in few different ways:</p>
</div>
<div class="paragraph data-line-1917">
<p>Some languages provide an API for dealing with threads. This model is called 1:1, because one OS thread calls one language thread. This is the Rust standard library implementation.</p>
</div>
<div class="paragraph data-line-1919">
<p>Some provide their own special implementation of threads. This is called M:N model, because this can run M threads per N OS. This can be achieved through crates(with the corresponding runtime overhead).
Spawn:</p>
</div>
<div class="paragraph data-line-1922">
<p><strong>Creating a new thread</strong></p>
</div>
<div class="listingblock data-line-1924">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">thread::spawn( | | {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
//spawn thread will die once main thread finishes, so it will be able to print only 5 values.
   for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
    });</code></pre>
</div>
</div>
<div class="paragraph data-line-1940">
<p><strong>Join: waiting for all threads to finish</strong></p>
</div>
<div class="paragraph data-line-1942">
<p>Previous code stops prematurely and also doesn’t guarantee that the spawned thread will get to run at all. We can store the return value of thread::spawn which is a joinhandle, an owned value that when we call join method, will wait for its thread to finish.</p>
</div>
<div class="listingblock data-line-1943">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let handle = thread::spawn(|| {
    for i in 1..10 {
        println!("hi number {} from the spawned thread!", i);
        thread::sleep(Duration::from_millis(1));
    }
});
// handle.join().unwrap();		//if we move the join handle, it will run everything on the spawn thread first
for i in 1..5 {
    println!("hi number {} from the main thread!", i);
    thread::sleep(Duration::from_millis(1));
}

handle.join().unwrap();		//waits for spawned thread to finish, alternating OS processing power.</code></pre>
</div>
</div>
<div class="paragraph data-line-1958">
<p><strong>Using data on multiple threads</strong></p>
</div>
<div class="paragraph data-line-1960">
<p>The <span class="blue">move</span> closure is often used alongside thread::spawn to use data from one thread into another. Move keyword force the closure to take ownership of the values.</p>
</div>
<div class="listingblock data-line-1961">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let v = vec![1, 2, 3];
let handle = thread::spawn(move | | {
    println!("Here's a vector: {:?}", v);
});

handle.join().unwrap();</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1970">
<h3 id="_using_message_passing_to_transfer_data_between_threads">16.2. Using message passing to transfer data between threads</h3>
<div class="paragraph data-line-1971">
<p>A popular approach to ensuring safe concurrency is through message passing, where threads communicate by sending each other messages containing data. Rust accomplish message-sending with channel, a component that has transmitter and receiver.</p>
</div>
<div class="paragraph data-line-1973">
<p>First we can create a new channel using mpsc::channel (mpsc stands for multiple producer, single consumer). This means a channel can have multiple sending ends but only one receiving. Channel returns a tuple for transmitting and receiving end. To create multiple producers/transmitter, you can clone the tx end.</p>
</div>
<div class="paragraph data-line-1975">
<p>Then we can use <span class="blue">move</span> to take <span class="blue">tx</span> into the closure so the spawned thread owns tx, and transmitting thread uses <span class="blue">send()</span> method which returns a Result&lt;T, E&gt;(we use unwrap instead, for simplicity).</p>
</div>
<div class="paragraph data-line-1977">
<p>Finally Receiving end uses <span class="blue">recv()</span> which also returns a result so in case sending end closes, recv return an error.</p>
</div>
<div class="listingblock data-line-1978">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from("hi");
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!("Got: {}", received);
}</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-1995">
<h3 id="_shared_state_concurrency">16.3. Shared-state Concurrency</h3>
<div class="paragraph data-line-1996">
<p>Message passing is a good way to handle concurrency/parallelism but we can also manage it with <span class="green">shared-memory</span>. Channels are similar to single ownership because once you transfer the value down a channel, you should no longer use it. Shared memory is like multiple ownership so we need mutexes to control access.</p>
</div>
<div class="paragraph data-line-1998">
<p><strong>Using mutexes to allow data from one thread at a time</strong></p>
</div>
<div class="paragraph data-line-2000">
<p>To access data in a mutex, a thread must first signal that it wants to aquire the mutex’s lock(data structure that controls access). You have to remember 2 rules when managing mutexes:</p>
</div>
<div class="ulist data-line-2002">
<ul>
<li class="data-line-2002">
<p>You must attempt to acquire the lock before using the data.</p>
</li>
<li class="data-line-2003">
<p>When you’re done with the data that the mutex guards, you must unlock the data so other threads can acquire the lock.
Mutex&lt;T&gt; API</p>
</li>
</ul>
</div>
<div class="listingblock data-line-2005">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use std::sync::Mutex;
let m = Mutex::new(5);		//smart pointer called MutexGuard.

{
    let mut num = m.lock().unwrap();		//will fail if another thread is holding the llock
    *num = 6;
}</code></pre>
</div>
</div>
<div class="paragraph data-line-2015">
<p><strong>Sharing a Mutex between multiple threads</strong></p>
</div>
<div class="paragraph data-line-2017">
<p>As we recall <span class="red">Rc should not be used on multithreaded systems</span>, Fortunately Arc is a type like Rc that is safe to use in concurrent situations. "A" stands for atomic. We normally do not use Arc because it comes with a performance penalty.</p>
</div>
<div class="listingblock data-line-2019">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">//let counter = Mutex::new(0);  //this yields an error due to owning
//let counter = Rc::new(Mutex::new(0));  //Rc doesn’t work on multiple threads
let counter = Arc::new(Mutex::new(0));   // Arc is a type like Rc that is safe in concurrent situations.
let mut handles = vec![];

for _ in 0..10 {
   let counter = Arc::clone(&amp;counter)
    let handle = thread::spawn(move || {
        let mut num = counter.lock().unwrap();

        *num += 1;
    });
    handles.push(handle);
}

for handle in handles {
    handle.join().unwrap();
}

println!("Result: {}", *counter.lock().unwrap());</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-2045">
<h3 id="_embedded_concurrency_with_sync_and_send_traits">16.4. Embedded concurrency with Sync and Send traits</h3>
<div class="paragraph data-line-2046">
<p><span class="blue">Send</span> marker trait indicates that <strong>ownership</strong> of values of the type implementing Send can be <strong>transferred between threads</strong>.</p>
</div>
<div class="paragraph data-line-2048">
<p><span class="blue">Sync</span> marker trait indicates that it is safe for the type implementing Sync to be <strong>referenced from multiple threads</strong></p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-2051">
<h2 id="_object_oriented_programming">17. Object Oriented Programming</h2>
<div class="sectionbody">
<div class="paragraph data-line-2052">
<p>Rust implements some features of OOP languages like:</p>
</div>
<div class="ulist data-line-2054">
<ul>
<li class="data-line-2054">
<p>Encapsulation: hiding implementation details to external code &#8594; pub keyword</p>
</li>
<li class="data-line-2055">
<p>Objects: A package of data and procedures &#8594; structs and enums have data, and impl blocks provide methods on structs and enums.</p>
</li>
<li class="data-line-2056">
<p><span class="red">Inheritance</span>: inherit data and behavior from another object definition. &#8594; There is <span class="red">no way for Rust</span> to define a struct that inherits parent struct field and methods. However, Rust provides means to reuse implementations with generics or to use default implementations with traits.</p>
</li>
<li class="data-line-2057">
<p><span class="red">Polymorphism</span>: enable a child to be used in the same places as a parent type, this means, substitute multiple objects for each other at runtime if they share certain characteristics.  Rust instead <span class="green">uses generics to abstract over different possible types and trait bounds to impose constraints</span> on what those types must provide. This is sometimes called bounded parametric polymorphism.</p>
</li>
</ul>
</div>
<div class="sect2 data-line-2059">
<h3 id="_using_trait_objects_allow_values_of_different_types">17.1. Using trait objects: Allow values of different types</h3>
<div class="paragraph data-line-2060">
<p>In <a href="#_common_collections">Common collections</a>, we mentioned that vectors can only store elements of one type. We used SpreadsheetCell to hold integers, floats and text. This is perfect for items with fixed set of types.</p>
</div>
<div class="paragraph data-line-2062">
<p>However, we sometimes we want our user to be able to extend the set of types that are valid. For example on a GUI, you want to implement draw method on each component that we want to print on screen.</p>
</div>
<div class="paragraph data-line-2064">
<p><strong>Defining a trait for common behavior</strong></p>
</div>
<div class="paragraph data-line-2066">
<p>To provide drawable components, we can define a trait named Draw that will have one method named draw. Then, we define a vector that takes a trait object(a trait object point to an instance of a type and a table used to look up trait methods at runtime).</p>
</div>
<div class="listingblock data-line-2068">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">pub trait Draw {
    fn draw(&amp;self);
}

//We create a trait object by specifying some sort of pointer, such as a &amp; reference or a Box&lt;T&gt; smart pointer, then the dyn keyword, and then specifying the relevant trait.
pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph data-line-2087">
<p>A generic type parameter &lt;T&gt; <span class="red">can only be substituted with one concrete type at a time</span>, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime.</p>
</div>
<div class="paragraph data-line-2089">
<p><strong>Implementing a trait</strong></p>
</div>
<div class="paragraph data-line-2091">
<p>Then someone can use our GUI library to implement a selection box.</p>
</div>
<div class="listingblock data-line-2092">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">use gui::Draw;
use gui::{Button, Screen};

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}


fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from("Yes"),
                    String::from("Maybe"),
                    String::from("No"),
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from("OK"),
            }),
        ],
    };

    screen.run();
}</code></pre>
</div>
</div>
<div class="admonitionblock warning data-line-2133">
<table>
<tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph data-line-2134">
<p>Safety is required for trait objects</p>
</div>
<div class="paragraph data-line-2136">
<p>You can only make object-safe traits into trait objects. Rust forgets the concrete type implementing a trait once you&#8217;ve used a trait objects, which basically means that:</p>
</div>
<div class="ulist data-line-2138">
<ul>
<li class="data-line-2138">
<p>The return type must not be Self.</p>
</li>
<li class="data-line-2139">
<p>There should be no generic type parameters.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2 data-line-2142">
<h3 id="_implementing_object_oriented_design_pattern">17.2. Implementing Object-Oriented design pattern</h3>
<div class="paragraph data-line-2143">
<p>We will implement a blog post workflow that has the following functionalities:</p>
</div>
<div class="ulist data-line-2145">
<ul>
<li class="data-line-2145">
<p>A blog post starts as an empty draft.</p>
</li>
<li class="data-line-2146">
<p>When the draft is done, a review of the post is requested.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-2148">
<p>Using state pattern design: a value has some internal state which is represented by a set of state objects and values behavior changes based on the internal state. so we dont need to change code value but behavior of state objects.</p>
</div>
<div class="paragraph data-line-2150">
<p><strong>Defining post and creating new instance in draft state</strong></p>
</div>
<div class="paragraph data-line-2152">
<p>When we create a new Post, we set its state field to a Some value that holds a Box. This Box points to a new instance of the Draft struct. This ensures whenever we create a new instance of Post, it will start out as a draft</p>
</div>
<div class="listingblock data-line-2154">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    // --snip--
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }

    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(self)
    }
// ability to change state from draft to Pending review
    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review()) // Calls internal request_review
        }
    }
}

// shared behavior by different post states
trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        ""
    }
}

struct Draft {}

// internal request review for Draft
impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

// internal request review for Pending review
impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}</code></pre>
</div>
</div>
<div class="paragraph data-line-2211">
<p><strong>Trade-off of state pattern</strong></p>
</div>
<div class="paragraph data-line-2213">
<p>The methods on Post know nothing about the various behaviors. The way we organized the code, we have to look in only one place to know the different ways a published post can behave: the implementation of the State trait on the Published struct.</p>
</div>
<div class="paragraph data-line-2215">
<p>The downsides of state pattern is that two adjacent states are coupled to each other. Also some duplicated logic exists.</p>
</div>
<div class="paragraph data-line-2217">
<p>If we were to create an alternative implementation that didn’t use the state pattern, we might instead use match expressions in the methods on Post or implementing transitions as different types(Post can be published but DraftPost cannot).</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-2219">
<h2 id="_patterns_and_matching">18. Patterns and Matching</h2>
<div class="sectionbody">
<div class="paragraph data-line-2220">
<p>Patterns give you more control over the porgrams flow, a pattern consist of:</p>
</div>
<div class="ulist data-line-2222">
<ul>
<li class="data-line-2222">
<p>Literals</p>
</li>
<li class="data-line-2223">
<p>Destructured arrays, enums, structs, or tuples</p>
</li>
<li class="data-line-2224">
<p>Variables</p>
</li>
<li class="data-line-2225">
<p>Wildcards</p>
</li>
<li class="data-line-2226">
<p>Placeholders</p>
</li>
</ul>
</div>
<div class="paragraph data-line-2228">
<p>To use a pattern, we compare it to some value. If the pattern matches the value, we use the value parts in our code.</p>
</div>
<div class="sect2 data-line-2230">
<h3 id="_patterns_use_cases">18.1. Patterns use cases</h3>
<div class="paragraph data-line-2232">
<p><strong>Match arms</strong></p>
</div>
<div class="paragraph data-line-2234">
<p>All posibilities must be handled.</p>
</div>
<div class="listingblock data-line-2235">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">match VALUE {
    PATTERN1 | PATTERN2  =&gt; EXPRESSION,     //multiple patterns
    PATTERN if condition &lt; 5 =&gt; EXPRESSION, //extra conditions
    range0..=range_last =&gt; EXPRESSION,      //range
    _ =&gt; Expression //handles any other case
}</code></pre>
</div>
</div>
<div class="paragraph data-line-2244">
<p><strong>Conditional if let</strong></p>
</div>
<div class="paragraph data-line-2246">
<p>Shorter way of matching only one case. However is not exhaustive(possible logic bugs).</p>
</div>
<div class="listingblock data-line-2248">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = "34".parse();

    if let Some(color) = favorite_color {
        println!("Using your favorite color, {}, as the background", color);
    } else if is_tuesday {
        println!("Tuesday is green day!");</code></pre>
</div>
</div>
</div>
<div class="sect2 data-line-2259">
<h3 id="_refutability_wether_a_pattern_might_fail_or_match">18.2. Refutability: wether a pattern might Fail or match</h3>
<div class="paragraph data-line-2260">
<p>Patterns come in two forms: refutable and irrefutable. Patterns that will match for any possible value passed are irrefutable(let x = 5) and patterns that can fail are refutable as Some(x).</p>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-2262">
<h2 id="_advanced_features">19. Advanced features</h2>
<div class="sectionbody">
<div class="paragraph data-line-2263">
<p>Here are some of the most advanced features in Rusts that are useful in very specific situations:</p>
</div>
<div class="ulist data-line-2265">
<ul>
<li class="data-line-2265">
<p>Unsafe Rust: how to opt out of some of Rust’s guarantees and take responsibility for manually upholding those guarantees</p>
</li>
<li class="data-line-2266">
<p>Advanced traits: associated types, default type parameters, fully qualified syntax, supertraits, and the newtype pattern in relation to traits</p>
</li>
<li class="data-line-2267">
<p>Advanced types: more about the newtype pattern, type aliases, the never type, and dynamically sized types</p>
</li>
<li class="data-line-2268">
<p>Advanced functions and closures: function pointers and returning closures
Macros: ways to define code that defines more code at compile time</p>
</li>
</ul>
</div>
<div class="sect2 data-line-2271">
<h3 id="_unsafe_rust">19.1. Unsafe Rust</h3>
<div class="paragraph data-line-2272">
<p>Unsafe Rust exists because, by nature, static analysis is conservative. Although the code might be okay, if the Rust compiler doesn’t have enough information to be confident, it will reject the code. In these cases, you can use unsafe code to tell the compiler, <span class="green"><strong>“Trust me, I know what I’m doing.”</strong></span> (The downside is that you use it at your own risk).</p>
</div>
<div class="paragraph data-line-2274">
<p>Another reason Rust has an unsafe alter ego is that the <strong>underlying computer hardware is inherently unsafe</strong>. If Rust didn’t let you do unsafe operations, you couldn’t do certain tasks. Rust needs to allow you to do low-level systems programming, such as directly interacting with the operating system or even writing your own operating system.</p>
</div>
<div class="paragraph data-line-2276">
<p><strong>Unsafe superpower</strong></p>
</div>
<div class="paragraph data-line-2278">
<p>To switch to unsafe Rust, use the <span class="blue">unsafe</span> keyword and then start a new block that holds the unsafe code. You can take five actions in unsafe Rust, called unsafe superpowers:</p>
</div>
<div class="ulist data-line-2280">
<ul>
<li class="data-line-2280">
<p>Dereference a raw pointer</p>
</li>
<li class="data-line-2281">
<p>Call an unsafe function or method</p>
</li>
<li class="data-line-2282">
<p>Access or modify a mutable static variable</p>
</li>
<li class="data-line-2283">
<p>Implement an unsafe trait</p>
</li>
<li class="data-line-2284">
<p>Access fields of unions</p>
</li>
</ul>
</div>
<div class="paragraph data-line-2286">
<p>Unsafe doesn&#8217;t turn off the borrow checker or disable any other safety check apart from these 5 actions. In addition, unsafe does not mean the code inside the block is necessarily dangerous or that it will definitely have memory safety problems: the intent is that as the programmer, you’ll ensure the code inside an unsafe block will access memory in a valid way. However, mistakes can still happen but they will be within unsafe blocks.</p>
</div>
<div class="paragraph data-line-2288">
<p><strong>Dereferencing a raw pointer</strong></p>
</div>
<div class="paragraph data-line-2290">
<p>Unsafe Rust has two new types called raw pointers that are similar to references. As with references, raw pointers can be immutable or mutable and are written as *const T and *mut T, respectively. raw ponters:</p>
</div>
<div class="ulist data-line-2292">
<ul>
<li class="data-line-2292">
<p>Are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</p>
</li>
<li class="data-line-2293">
<p>Aren’t guaranteed to point to valid memory</p>
</li>
<li class="data-line-2294">
<p>Are allowed to be null</p>
</li>
<li class="data-line-2295">
<p>Don’t implement any automatic cleanup</p>
</li>
</ul>
</div>
<div class="listingblock data-line-2297">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">fn main() {
    let address = 0x012345usize;  //raw ,memory location(NOT RECOMMENDED)
// we can create raw pointers in safe code but we cant dereference outside unsafe.
    let r1 = &amp;num as *const i32;        //immutable raw pointer
    let r2 = &amp;mut num as *mut i32;      //mutable raw pointer
}</code></pre>
</div>
</div>
<div class="paragraph data-line-2307">
<p><strong>Calling unsafe functions  or methods</strong></p>
</div>
<div class="listingblock data-line-2309">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">unsafe fn dangerous() {}

unsafe {
    dangerous();
}</code></pre>
</div>
</div>
<div class="paragraph data-line-2317">
<p><strong>Using extern function to call external code</strong></p>
</div>
<div class="paragraph data-line-2319">
<p>Rust code might need to interact with code written in another language. Rust has a keyword, extern, that facilitates the creation and use of a Foreign Function Interface (FFI).</p>
</div>
<div class="listingblock data-line-2320">
<div class="content">
<pre class="highlight"><code class="language-Rust" data-lang="Rust">// integration with C language
extern "C" {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!("Absolute value of -3 according to C: {}", abs(-3));
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2022-10-09 19:54:47 -0500
</div>
</div>
</body>
</html>